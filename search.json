[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programming for Analytics in R",
    "section": "",
    "text": "Welcome\nThis is the website for the 1st edition of “Programming for Analytics in R”.\nThis book was originally written as a companion set of readings for the course “EMSE 4571 / 6571: Intro. to Programming for Analytics” at GWU. The book teaches you how to program in R and how to do some basic data science with R. It is designed for novice coders with little to no prior programming experience.\nAfter reading this book, you should be able to:\n\nDevelop simple programs to effectively solve medium-sized tasks by:\n\nEmploying modular, top-down design in program construction.\nPro-actively creating and writing test cases to test and debug code.\nApplying computational problem-solving skills to new problems.\n\nWrite clear, robust, and reasonably efficient code for working with data using:\n\nSequential, conditional, and loop statements.\nNumeric, string, and logical data types.\nData structures, including lists, vectors, and data frames.\n\nReproducibly import, export, wrangle, and visualize data in R.\n\nThis website is and will always be free, licensed under the CC BY-NC-ND 3.0 License.\nIf you appreciate reading the book for free, please leave feedback on the GitHub repository for the source code to the book."
  },
  {
    "objectID": "intro.html#what-you-will-learn",
    "href": "intro.html#what-you-will-learn",
    "title": "1  Introduction",
    "section": "\n1.1 What you will learn",
    "text": "1.1 What you will learn\nThe goal of the book is to develop a foundation in two domains:\n\nLiteracy in programming and computational thinking.\nLiteracy in data analytics.\n\nThis book implements both domains in R - an open source and powerful language for both programming and data science.\n\n1.1.1 Programming\nJust like learning a spoken language, learning to program in a computing language requires lots of practice. In that regard, this book is designed as a guidebook or reference manual for your practice. It explains many of the most fundamental aspects of the R programming language, such as operators, data types, functions, conditional statements, testing, debugging, iteration, vectors, and strings. Becoming fluent in these concepts requires many hours of practice writing code. By the end of the first main section of the book on “Programming,” you should be familiar with these concepts, but by no means should you expect to already be fluent in them. It is fully expected that you will return to these chapters many times as you practice and become more fluent at programming in R.\n\n1.1.2 Data Analytics\nThe name “data analytics” was carefully chosen to emphasize an important distinction with the broader category of “data science”. Whereas data analytics involves importing, exporting, cleaning, wrangling, and visualizing data, the broader category of “data science” includes modeling, in which data are used to estimate or train models used for inference or prediction.\nWhile this book does not cover modeling, the data concepts it does cover are all critical for being able to work with, inspect, and prepare data for modeling. In this section of the book, you will learn how to import and export data to and from R. You will also learn about the core data structure used to work with tabular data in R: the data frame. You will learn how to “wrangle” data in data frames and use them to make data visualizations. For this section, we will rely heavily on the tidyverse, a collection of R packages, data, and documentation that extends the capabilities of base R for working with data."
  },
  {
    "objectID": "intro.html#software",
    "href": "intro.html#software",
    "title": "1  Introduction",
    "section": "\n1.2 Software",
    "text": "1.2 Software\nYou will need both R and RStudio for this book. You will also need to install some R packages, but we’ll get to those later.\n\n1.2.1 R\nYou can download and install R from CRAN, the Comprehensive R Archive Network, at https://cloud.r-project.org/index.html This book assumes you will install at least R 4.1.0 for this book.\n\n1.2.2 RStudio\nRStudio is an “Integrated Development Environment (IDE) for programming in R. Download and install it from https://posit.co/download/rstudio-desktop/."
  },
  {
    "objectID": "programming.html",
    "href": "programming.html",
    "title": "Programming",
    "section": "",
    "text": "The goal of this section is to develop a general literacy in programming and computational thinking. While we will focus on learning these concepts in R, they will translate well to other similar languages, such as Python and Matlab.\nGo on to the next page to get started on your journey learning to program in R!"
  },
  {
    "objectID": "getting-started.html#r-and-rstudio",
    "href": "getting-started.html#r-and-rstudio",
    "title": "2  Getting Started",
    "section": "\n2.1 R and RStudio",
    "text": "2.1 R and RStudio\nR is a programming language that runs computations, and RStudio is an interface for working with R with a lot of convenient tools and features. It is the primary integrated development environment (IDE) for R users.\nYou can think of the two like this:\n\nR is like a car’s engine.\nRStudio is like a car’s dashboard.\n\n\n\n\n\n\n\nR: Engine\nRStudio: Dashboard\n\n\n\n\n\n\nYour car needs an engine (R) to run, but having a speedometer and rear view mirrors (RStudio) makes driving a lot easier.\nTo get started using R , you need to download and install both R and RStudio (Desktop version) on your computer. Go to the introduction chapter for instructions.\nOnce you have everything installed, open RStudio. You should see the following:\n\n\nA typical RStudio session\n\n\nNotice the default panes:\n\nConsole (entire left)\nEnvironment/History (tabbed in upper right)\nFiles/Plots/Packages/Help (tabbed in lower right)\n\nFYI: you can change the default location of the panes, among many other things: Customizing RStudio.\nGo into the Console on the left with the > (that’s the command prompt).\nLet’s get started using R!"
  },
  {
    "objectID": "getting-started.html#your-first-conversation",
    "href": "getting-started.html#your-first-conversation",
    "title": "2  Getting Started",
    "section": "\n2.2 Your first conveRsation",
    "text": "2.2 Your first conveRsation\nWhen you type something into the console, R will give you a reply. Think of it like having a conversation with R. For example, let’s ask R to add two numbers:\n\n3 + 4\n\n#> [1] 7\n\n\nAs you probably expected, R returned 7. No surprises here!\n\nQuick note: you can ignore the [1] you see in the returned value…that’s just R saying there’s only one value to return.\n\nBut what happens if you ask R to add a number surrounded by quotations marks?\n\n3 + \"4\"\n\n#> Error in 3 + \"4\": non-numeric argument to binary operator\n\n\nLooks like R didn’t like that. That’s because you asked R to add a number to something that is not a number (\"4\" is a character, which is different from the number 4), so R returned an error message. This is R’s what of telling you that you asked it to do something that it can’t do.\nHere’s a helpful tip:\n\nEMBRACE THE ERROR MESSAGES!\n\nBy the end of this course, you will have seen loads of error messages. This doesn’t mean you “can’t code” or that you’re “bad at coding” - it just means you’ve still got more work to do to solve the problem.\nIn fact, the best coders sometimes intentionally write code with known errors in it in order to get an error message. This is because when R gives you an error message, most of the time there is a hint in it that can help you solve the problem that led to the error. For example, take a look at the error message from the last example:\nError in 3 + \"4\" : non-numeric argument to binary operator\nHere R is saying that there was a “non-numeric argument” somewhere. That suggests that the problem might be with something not being a number. As we just discussed, \"4\" is a character, or a “non-numeric argument”.\nWith practice, you’ll get better at embracing and interpreting R’s error messages."
  },
  {
    "objectID": "getting-started.html#storing-values",
    "href": "getting-started.html#storing-values",
    "title": "2  Getting Started",
    "section": "\n2.3 Storing values",
    "text": "2.3 Storing values\nYou can store values by “assigning” them to an object with the <- symbol, like this:\n\nx <- 2\n\nHere the symbol <- is meant to look like an arrow. It means “assign the value 2 to the object named x”.\n\nPRO TIP: To quickly type <-, use the shortcut option + - (mac) or alt + - (windows). There are lots of other helpful shortcuts. Type Alt + Shift + K to bring up a shortcut reference card).\n\nSince we assigned the value 2 to x, if we type x into the console and press “enter” R will return the stored value:\n\nx\n\n#> [1] 2\n\n\nIf you overwrite an object with a different value, R will “forget” the previous assigned value and only keep the new assignment:\n\nx <- 42\nx\n\n#> [1] 42\n\n\n\nPRO TIP: Always surround <- with spaces to avoid confusion! For example, if you typed x<-2 (no spaces), it’s not clear if you meant x <- 2 or x < -2. The first one assigns 2 to x, but the second one compares whether x is less than -2.\n\n\n2.3.1 Use meaningful variable names\nYou can choose almost any name you like for an object, so long as the name does not begin with a number or a special character like +, -, *, /, ^, !, @, or &. But you should always use variable names that describe the thing you’re assigning. This practice will save you major headaches later when you have lots of objects in your environment.\nFor example, let’s say you have measured the length of a caterpillar and want to store it as an object. Here are three options for creating the object:\nPoor variable name:\n\nx <- 42\n\nGood variable name:\n\nlength_mm <- 42\n\nEven better variable name:\n\ncaterpillar_length_mm <- 42\n\nThe first name, x, tells us nothing about what the value 42 means (are we counting something? 42 of what?). The second name, length_mm, tells us that 42 is the length of something, and that it’s measured in millimeters. Finally, the last name, caterpillar_length_mm, tells us that 42 is the length of a caterpillar, measured in millimeters.\n\n2.3.2 Use standard casing styles\n Art by Allison Horst\nYou will be wise to adopt a convention for demarcating words in names. I recommend using one of these:\n\nsnake_case_uses_underscores\ncamelCaseUsesCaps\n\nMake another assignment:\n\nthis_is_a_long_name <- 2.5\n\nTo inspect this, try out RStudio’s completion facility: type the first few characters, press TAB - voila! RStudio auto-completes the long name for you :)\n\n2.3.3 R is case sensitive\nTo understand what this means, try this:\n\ncases_matter <- 2\nCases_matter <- 3\n\nLet’s try to inspect:\n\ncases_matter\n\n#> [1] 2\n\nCases_matter\n\n#> [1] 3\n\n\nAlthough the two objects look_ similar, one has a capital “C”, and R stores that as a different object.\nIn general, type carefully. Typos matter. Case matters. Get better at typing.\n\n2.3.4 The workspace\nLook at your workspace in the upper-right pane. The workspace is where user-defined objects accumulate. You can also get a listing of these objects with commands:\n\nobjects()\n\n#> [1] \"cases_matter\"          \"Cases_matter\"          \"caterpillar_length_mm\"\n#> [4] \"length_mm\"             \"this_is_a_long_name\"   \"x\"\n\nls()\n\n#> [1] \"cases_matter\"          \"Cases_matter\"          \"caterpillar_length_mm\"\n#> [4] \"length_mm\"             \"this_is_a_long_name\"   \"x\"\n\n\nIf you want to remove the object named x, you can do this\n\nrm(x)\n\nTo remove everything, use this:\n\nrm(list = ls())\n\nor click the broom symbol."
  },
  {
    "objectID": "getting-started.html#what-else-can-r-do",
    "href": "getting-started.html#what-else-can-r-do",
    "title": "2  Getting Started",
    "section": "\n2.4 What else can R do?",
    "text": "2.4 What else can R do?\nR can do a LOT more than what we’ve seen thus far. For example, you can ask R to print text to the console using the cat() function:\n\ncat(\"Hello world!\")\n\n#> Hello world!\n\n\nIn the next section, we’ll learn more about some of the distinctions between different types of values in R (like numbers and characters).\nWhile R is a programming language, it is perhaps most commonly known as a tool for analyzing data and creating plots. For example, here’s how you can use R to make a simple plot of the equation \\(y = x^2\\):\n\nx <- seq(from = -10, to = 10)\ny <- x^2\nplot(x, y)\nlines(x, y)\n\n\n\n\n\n\n\nBut you can plot way more than equations in R! For example, take a look at this plot of some actual data about penguins (don’t worry about the code for now - by the end of this course you’ll know what it all does!):\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) +\n  geom_point(aes(color = species, shape = species),\n             size = 3, alpha = 0.8) +\n  scale_color_manual(values = c(\"darkorange\",\"purple\",\"cyan4\")) +\n  theme_minimal() +\n  labs(title = \"Penguin size, Palmer Station LTER\",\n       subtitle = \"Flipper length and body mass for Adelie, Chinstrap, and Gentoo Penguins\",\n       x = \"Flipper length (mm)\",\n       y = \"Body mass (g)\",\n       color = \"Penguin species\",\n       shape = \"Penguin species\") +\n  theme(legend.position = c(0.2, 0.7),\n        legend.background = element_rect(fill = \"white\", color = NA),\n        plot.title.position = \"plot\",\n        plot.caption = element_text(hjust = 0, face= \"italic\"),\n        plot.caption.position = \"plot\")"
  },
  {
    "objectID": "getting-started.html#a-couple-more-important-points",
    "href": "getting-started.html#a-couple-more-important-points",
    "title": "2  Getting Started",
    "section": "\n2.5 A couple more important points",
    "text": "2.5 A couple more important points\n\n2.5.1 R ignores excess spacing\nWhen I typed 3 + 4 before, I could equally have done this\n\n3        + 4\n\n#> [1] 7\n\n\nor this\n\n            3   + 4\n\n#> [1] 7\n\n\nBoth produce the same result. The point here is that R ignores extra spaces. This may seem irrelevant for now, but in some programming languages (e.g. Python) blank spaces matter a lot!\nThis doesn’t mean extra spaces never matter. For example, if you wanted to input the value 3.14 but you put a space after the 3, you’ll get an error:\n\n3   .14\n\n#> Error: <text>:1:5: unexpected numeric constant\n#> 1: 3   .14\n#>         ^\n\n\nBasically, you can put spaces between different values, and you can put as many as you want and R won’t care. But if you break a value up with a space, R will send an error message.\n\n2.5.2 Using comments\nIn R, the # symbol is a special symbol that denotes a comment. R will ignore anything on the same line that follows the # symbol. This enables us to write comments around our code to explain what we’re doing:\n\nspeed <- 55 # This is km/h, not mph!\nspeed\n\n#> [1] 55\n\n\nNotice that R ignores the whole sentence after the # symbol."
  },
  {
    "objectID": "getting-started.html#staying-organized",
    "href": "getting-started.html#staying-organized",
    "title": "2  Getting Started",
    "section": "\n2.6 Staying organized",
    "text": "2.6 Staying organized\n\n2.6.1 The history pane\nR keeps track of your “command history.” If you click on the console and hit the “up” key, the R console will show you the most recent command that you’ve typed. Hit it again, and it will show you the command before that, and so on.\nThe second way to get access to your command history is to look at the history panel in Rstudio. On the upper right hand side of the Rstudio window you’ll see a tab labeled “History.” Click on that and you’ll see a list of all your recent commands displayed in that panel. It should look something like this:\n\n\n\nIf you double click on one of the commands, it will be copied to the R console.\n\n2.6.2 Working directory\nAny process running on your computer has a notion of its “working directory”. In R, this is where R will look for files you ask it to load. It’s also where any files you write to disk will go.\nYou can explicitly check your working directory with:\n\ngetwd()\n\nIt is also displayed at the top of the RStudio console.\nAs a beginning R user, it’s OK let your home directory or any other weird directory on your computer be R’s working directory. Very soon, I urge you to evolve to the next level, where you organize your analytical projects into directories and, when working on project A, set R’s working directory to the associated directory.\nAlthough I do not recommend it, in case you’re curious, you can set R’s working directory at the command line like so:\n\nsetwd(\"~/myCoolProject\")\n\nAlthough I do not recommend it, you can also use RStudio’s Files pane to navigate to a directory and then set it as working directory from the menu:\n\nSession > Set Working Directory > To Files Pane Location.\n\nYou’ll see even more options there). Or within the Files pane, choose More and Set As Working Directory.\nBut there’s a better way. A way that also puts you on the path to managing your R work like an expert.\n\n2.6.3 RStudio projects\nKeeping all the files associated with a project organized together – input data, R scripts, analytical results, figures – is such a wise and common practice that RStudio has built-in support for this via its projects.\nUsing Projects\nLet’s make one for practice. Do this:\n\nFile > New Project ….\n\nYou should see the following pane:\n\n\n\nChoose “New Directory”. The directory name you choose here will be the project name. Call it whatever you want. RStudio will create a folder with that name to put all your project files.\nAs a demo, I created a project on my Desktop called “demo”. RStudio created a new project called “demo”, and in this folder there is a file called “demo.Rproj”. If I double-click on this file, RStudio will open up, and my working directory will be automatically set to this folder! You can double check this by typing:\n\ngetwd()\n\n\n2.6.4 Save your code in .R Files\nIt is traditional to save R scripts with a .R or .r suffix. Any code you wish to re-run again later should be saved in this way and stored within your project folder. For example, if you wanted to re-run all of the code in this tutorial, open a new .R file and save it to your R project folder. Do this:\n\nFile > New File > R Script\n\nYou can copy some of the code we’ve typed so far into this file to re-run it again later:\n\n3 + 4\n3 + \"4\"\nx <- 2\nx\nx <- 42\nx\nthis_is_a_long_name <- 2.5\ncases_matter <- 2\nCases_matter <- 3\ncases_matter\nCases_matter\nobjects()\nls()\nrm(x)\nrm(list = ls())\ncat(\"Hello world!\")\nx <- seq(from = -10, to = 10)\ny <- x^2\nplot(x, y)\nlines(x, y)\n3        + 4\n            3   + 4\n2 + 2 # I'm adding two numbers\ngetwd()\n\nThen save this new R script with some name. Do this:\n\nFile > Save\n\nI called the file “tutorial.R” and saved it in my R project folder called “demo”.\nNow when I open the “demo.Rproj” file, I see in my files pane the “tutorial.R” code script. I can click on that file and continue editing it!\nI can also run any line in the script by typing “Command + Enter” (Mac) or “Control + Enter” (Windows)."
  },
  {
    "objectID": "getting-started.html#page-sources",
    "href": "getting-started.html#page-sources",
    "title": "2  Getting Started",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nPalmer penguins plot from the palmerpenguins package by Allison Horst.\n“Case” art by Allison Horst\n\nDanielle Navarro’s book “Learning Statistics With R”\n\nJenny Bryan’s STAT 545 Course\n\n\nModern Dive, by Chester Ismay & Albert Y. Kim"
  },
  {
    "objectID": "functions-packages.html#functions",
    "href": "functions-packages.html#functions",
    "title": "3  Functions & Packages",
    "section": "\n3.1 Functions",
    "text": "3.1 Functions\nYou can do a lot with the basic operators like +, -, and *, but to do more advanced calculations you’re going to need to start using functions.1\n\nWatch this 1-minute video for a quick summary of functions\n\nR has a lot of very useful built-in functions. For example, if I wanted to take the square root of 225, I could use R’s built-in square root function sqrt():\n\nsqrt(225)\n\n#> [1] 15\n\n\nHere the letters sqrt are short for “square root,” and the value inside the () is the “argument” to the function. In the example above, the value 225 is the “argument”.\nKeep in mind that not all functions have (or require) arguments:\n\ndate() # Returns the current date and time\n\n#> [1] \"Thu Jan  5 21:39:35 2023\"\n\n\n(the date above is the date this page was last built)\n\n3.1.1 Multiple arguments\nSome functions have more than one argument. For example, the round() function can be used to round some value to the nearest integer or to a specified decimal place:\n\nround(3.14165)    # Rounds to the nearest integer\n\n#> [1] 3\n\nround(3.14165, 2) # Rounds to the 2nd decimal place\n\n#> [1] 3.14\n\n\nNot all arguments are mandatory. With the round() function, the decimal place is an optional input - if nothing is provided, the function will round to the nearest integer by default.\n\n3.1.2 Argument names\nIn the case of round(), it’s not too hard to remember which argument comes first and which one comes second. But it starts to get very difficult once you start using complicated functions that have lots of arguments. Fortunately, most R functions use argument names to make your life a little easier. For the round() function, for example, the number that needs to be rounded is specified using the x argument, and the number of decimal points that you want it rounded to is specified using the digits argument, like this:\n\nround(x = 3.1415, digits = 2)\n\n#> [1] 3.14\n\n\n\n3.1.3 Default values\nNotice that the first time I called the round() function I didn’t actually specify the digits argument at all, and yet R somehow knew that this meant it should round to the nearest whole number. How did that happen? The answer is that the digits argument has a default value of 0, meaning that if you decide not to specify a value for digits then R will act as if you had typed digits = 0.\nThis is quite handy: most of the time when you want to round a number you want to round it to the nearest whole number, and it would be pretty annoying to have to specify the digits argument every single time. On the other hand, sometimes you actually do want to round to something other than the nearest whole number, and it would be even more annoying if R didn’t allow this! Thus, by having digits = 0 as the default value, we get the best of both worlds.\n\n3.1.4 Function help\nNot sure what a function does, how many arguments it has, or what the argument names are? Ask R for help by typing ? and then the function name, and R will return some documentation about it. For example, type ?round() into the console and R will return information about how to use the round() function.\n\n3.1.5 Combining functions\nIn the same way that R allows us to put multiple operations together into a longer command (like 1 + 2 * 4 for instance), it also lets us put functions together and even combine functions with operators if we so desire. For example, the following is a perfectly legitimate command:\n\nround(sqrt(7), digits = 2)\n\n#> [1] 2.65\n\n\nWhen R executes this command, starts out by calculating the value of sqrt(7), which produces an intermediate value of 2.645751. The command then simplifies to round(2.645751, digits = 2), which rounds the value to 2.65."
  },
  {
    "objectID": "functions-packages.html#frequently-used-functions",
    "href": "functions-packages.html#frequently-used-functions",
    "title": "3  Functions & Packages",
    "section": "\n3.2 Frequently used functions",
    "text": "3.2 Frequently used functions\n\n3.2.1 Math functions\nR has LOTS of functions. Many of the basic math functions are somewhat self-explanatory, but it can be hard to remember the specific function name. Below is a reference table of some frequently used math functions.\n\n\n\n\n\n\n\n\nFunction\nDescription\nExample input\nExample output\n\n\n\nround(x, digits=0)\nRound x to the digits decimal place\nround(3.1415, digits=2)\n3.14\n\n\nfloor(x)\nRound x down the nearest integer\nfloor(3.1415)\n3\n\n\nceiling(x)\nRound x up the nearest integer\nceiling(3.1415)\n4\n\n\nabs()\nAbsolute value\nabs(-42)\n42\n\n\nmin()\nMinimum value\nmin(1, 2, 3)\n1\n\n\nmax()\nMaximum value\nmax(1, 2, 3)\n3\n\n\nsqrt()\nSquare root\nsqrt(64)\n8\n\n\nexp()\nExponential\nexp(0)\n1\n\n\nlog()\nNatural log\nlog(1)\n0\n\n\nfactorial()\nFactorial\nfactorial(5)\n120\n\n\n\n3.2.2 Functions for manipulating data types\nYou will often need to check the data type of objects and convert them to other types. To handle this, use these patterns:\n\nCheck the type of x: is.______()\n\nConvert the type of x: as.______()\n\n\nIn each of these patterns, replace “______” with:\n\ncharacter\nlogical\n\nnumeric / double / integer\n\n\n\n3.2.2.1 Converting data types\nYou can convert an object from one type to another using as.______(), replacing “______” with a data type:\nConvert numeric types:\n\nas.numeric(\"3.1415\")\n\n#> [1] 3.1415\n\nas.double(\"3.1415\")\n\n#> [1] 3.1415\n\nas.integer(\"3.1415\")\n\n#> [1] 3\n\n\nConvert non-numeric types:\n\nas.character(3.1415)\n\n#> [1] \"3.1415\"\n\nas.logical(3.1415)\n\n#> [1] TRUE\n\n\nA few notes to keep in mind:\n\nWhen converting from a numeric to a logical, as.logical() will always return TRUE for any numeric value other than 0, for which it returns FALSE.\n\n\nas.logical(7)\n\n#> [1] TRUE\n\nas.logical(0)\n\n#> [1] FALSE\n\n\nThe reverse is also true\n\nas.numeric(TRUE)\n\n#> [1] 1\n\nas.numeric(FALSE)\n\n#> [1] 0\n\n\n\nNot everything can be converted. For example, if you try to coerce a character that contains letters into a number, R will return NA, because it doesn’t know what number to choose:\n\n\nas.numeric('foo')\n\n#> Warning: NAs introduced by coercion\n\n\n#> [1] NA\n\n\n\nThe as.integer() function behaves the same as floor():\n\n\nas.integer(3.14)\n\n#> [1] 3\n\nas.integer(3.99)\n\n#> [1] 3\n\n\n\n3.2.2.2 Checking data types\nSimilar to the as.______() format, you can check if an object is a specific data type using is.______(), replacing “______” with a data type.\nChecking numeric types:\n\nis.numeric(3.1415)\n\n#> [1] TRUE\n\nis.double(3.1415)\n\n#> [1] TRUE\n\nis.integer(3.1415)\n\n#> [1] FALSE\n\n\nChecking non-numeric types:\n\nis.character(3.1415)\n\n#> [1] FALSE\n\nis.logical(3.1415)\n\n#> [1] FALSE\n\n\nOne thing you’ll notice is that is.integer() often gives you a surprising result. For example, why did is.integer(7) return FALSE?. Well, this is because numbers are doubles by default in R, so even though 7 looks like an integer, R thinks it’s a double.\nThe safer way to check if a number is an integer in value is to compare it against itself converted into an integer:\n\n7 == as.integer(7)\n\n#> [1] TRUE"
  },
  {
    "objectID": "functions-packages.html#more-functions-with-packages",
    "href": "functions-packages.html#more-functions-with-packages",
    "title": "3  Functions & Packages",
    "section": "\n3.3 More functions with packages\n",
    "text": "3.3 More functions with packages\n\nWhen you start R, it only loads the “Base R” functions (e.g. sqrt(), round(), etc.), but there are thousands and thousands of additional functions stored in external packages.\n\nWatch this 1-minute video for a quick summary of packages\n\n\n3.3.1 Installing packages\nTo install a package, use the install.packages() function. Make sure you put the package name in quotes:\n\ninstall.packages(\"packagename\") # This works\ninstall.packages(packagename)   # This doesn't work\n\nJust like most software, you only need to install a package once.\n\n3.3.2 Using packages\nAfter installing a package, you can’t immediately use the functions that the package contains. This is because when you start up R only the “base” functions are loaded. If you want R to also load the functions inside a package, you have to load that package, which you do with the library() function. In contrast to the install.packages() function, you don’t need quotes around the package name to load it:\n\nlibrary(\"packagename\") # This works\nlibrary(packagename)   # This also works\n\nHere’s a helpful image to keep the two ideas of installing vs loading separate:\n\n\n3.3.3 Example: wikifacts\n\nAs an example, try installing the Wikifacts package, by Keith McNulty:\n\ninstall.packages(\"wikifacts\") # Remember - you only have to do this once!\n\nNow that you have the package installed on your computer, try loading it using library(wikifacts), then trying using some of it’s functions:\n\nlibrary(wikifacts) # Load the library\n\n\nwiki_randomfact()\n\n#> [1] \"Did you know that endocrinologist Reginald Hall, who studied the thyroid gland and its diseases, received a heart transplant in 1984? (Courtesy of Wikipedia)\"\n\nwiki_didyouknow()\n\n#> [1] \"Did you know that the 2001 manga series World of the S&M was released in English as The World Exists for Me? (Courtesy of Wikipedia)\"\n\n\nIn case you’re wondering, the only thing this package does is generate messages containing random facts from Wikipedia.\n\n3.3.4 Using only some package functions\nSometimes you may only want to use a single function from a library without having to load the whole thing. To do so, use this recipe:\n\npackagename::functionname()\n\nHere I use the name of the package followed by :: to tell R that I’m looking for a function that is in that package. For example, if I didn’t want to load the whole wikifacts library but still wanted to use the wiki_randomfact() function, I could do this:\n\nwikifacts::wiki_randomfact()\n\n#> [1] \"Did you know that Kiriko, a \\\"fox girl\\\" character for Overwatch 2, was teased through a coded message that translates to \\\"What Does the Fox Say?\\\" (Courtesy of Wikipedia)\"\n\n\nWhere this is particularly handy is when two packages have a function with the same name. If you load both library, R might not know which function to use. In those cases, it’s best to also provide the package name. For example, let’s say there was a package called apples and another called bananas, and each had a function named fruitName(). If I wanted to use each of them in my code, I would need to specify the package names like this:\n\napples::fruitName()\nbananas::fruitName()"
  },
  {
    "objectID": "functions-packages.html#turtle-graphics",
    "href": "functions-packages.html#turtle-graphics",
    "title": "3  Functions & Packages",
    "section": "\n3.4 Turtle Graphics",
    "text": "3.4 Turtle Graphics\nTurtle graphics is a classic teaching tool in computer science, originally invented in the 1960s and re-implemented over and over again in different programming languages.\nIn R, there is a similar package called TurtleGraphics. To get started, install the package (remember, you only need to do this once on your computer):\n\ninstall.packages('TurtleGraphics')\n\nOnce installed, load the package (remember, you have to load this every time you restart R to use the package!):\n\nlibrary(TurtleGraphics)\n\n#> Loading required package: grid\n\n\n\n3.4.1 Getting to know your turtle\nHere’s the idea. You have a turtle, and she lives in a nice warm terrarium. The terrarium is 100 x 100 units in size, where the lower-left corner is at the (x, y) position of (0, 0). When you call turtle_init(), the turtle is initially positioned in the center of the terrarium at (50, 50):\n\nturtle_init()\n\n\nYou can move the turtle using a variety of movement functions (see ?turtle_move()), and she will leave a trail where ever she goes. For example, you can move her 10 units forward from her starting position:\n\nturtle_init()\nturtle_forward(distance = 10)\n\n\nYou can also make the turtle jump to a new position (without drawing a line) by using the turtle_setpos(x, y), where (x, y) is a coordinate within the 100 x 100 terrarium:\n\nturtle_init()\nturtle_setpos(x=10, y=10)\n\n\n\n3.4.2 Turtle loops\nSimple enough, right? But what if I want my turtle to draw a more complicated shape? Let’s say I want her to draw a hexagon. There are six sides to the hexagon, so the most natural way to write code for this is to write a for loop that loops over the sides (don’t worry if this doesn’t make sense yet - we’ll get to loops in week 5!). At each iteration within the loop, I’ll have the turtle walk forwards, and then turn 60 degrees to the left. Here’s what happens:\n\n\n\nturtle_init()\nfor (side in 1:6) {\n    turtle_forward(distance = 10)\n    turtle_left(angle = 60)\n}\n\nCool! As you draw more complex shapes, you can speed up the process by wrapping your turtle commands inside the turtle_do({}) function. This will skip the animations of the turtle moving and will jump straight to the final position. For example, here’s the hexagon again without animations:\n\nturtle_init()\nturtle_do({\n    for (side in 1:6) {\n        turtle_forward(distance = 10)\n        turtle_left(angle = 60)\n    }\n})"
  },
  {
    "objectID": "functions-packages.html#page-sources",
    "href": "functions-packages.html#page-sources",
    "title": "3  Functions & Packages",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nDanielle Navarro’s book “Learning Statistics With R”\n\nDanielle Navarro’s website “R for Psychological Science”\n\nJenny Bryan’s STAT 545 Course\n\nRStudio primers\nXiao Ping Song’s Intro2R crash course"
  },
  {
    "objectID": "operators-data-types.html#r-as-a-calculator",
    "href": "operators-data-types.html#r-as-a-calculator",
    "title": "4  Operators & Data Types",
    "section": "\n4.1 R as a calculator",
    "text": "4.1 R as a calculator\nYou can do a ton of things with R, but at its core it’s basically a fancy calculator. Let’s get started with some basic arithmetic!\n\n4.1.1 Doing basic math\nR handles simple arithmetic using the following arithmetic operators:\n\n\n\n\n\noperation\noperator\nexample input\nexample output\n\n\n\naddition\n+\n10 + 2\n12\n\n\nsubtraction\n-\n9 - 3\n6\n\n\nmultiplication\n*\n5 * 5\n25\n\n\ndivision\n/\n9 / 3\n3\n\n\npower\n^\n5 ^ 2\n25\n\n\n\n\n\n\nThe first four basic operators (+, -, *, /) are pretty straightforward and behave as expected:\n\n7 + 5 # Addition\n\n#> [1] 12\n\n7 - 5 # Subtraction\n\n#> [1] 2\n\n7 * 5 # Multiplication\n\n#> [1] 35\n\n7 / 5 # Division\n\n#> [1] 1.4\n\n\nNot a lot of surprises (you can ignore the [1] you see in the returned values…that’s just R saying there’s only one value to return).\nPowers (i.e. \\(x^n\\)) are represented using the ^ symbol. For example, to calculate \\(5^4\\) in R, we would type:\n\n5^4\n\n#> [1] 625\n\n\n\n4.1.2 Slightly more tricky math\nThere are two other operators that are not typically as well-known as the first five but are quite common in programming:\n\n\n\n\n\noperation\noperator\nexample input\nexample output\n\n\n\ninteger division\n%/%\n4 %/% 3\n1\n\n\nmodulus\n%%\n8 %% 3\n2\n\n\n\n\n\n\n\n4.1.2.1 Integer division\nInteger division is division in which the remainder is discarded. Note the difference between regular (/) and integer (%/%) division:\n\n4 / 3 # Regular division\n\n#> [1] 1.333333\n\n\n\n4 %/% 3 # Integer division\n\n#> [1] 1\n\n\nWith integer division, 3 can only go into 4 once, so 4 %/% 3 returns 1.\nWith integer division, dividing a number by a larger number will always produce 0 (because the larger number cannot go into the smaller number):\n\n4 %/% 5 # Will return 0\n\n#> [1] 0\n\n\n\n4.1.2.2 The Modulus operator\nThe modulus (aka “mod” operator) returns the remainder after doing integer division. For example:\n\n17 %% 3\n\n#> [1] 2\n\n\nThis returns 2 because because 17 / 3 is equal to 5 with a remainder of 2. The modulus returns any remainder, including decimals:\n\n3.1415 %% 3\n\n#> [1] 0.1415\n\n\nIf you mod a number by itself, you’ll get 0 (because there’s no remainder):\n\n17 %% 17 # Will return 0\n\n#> [1] 0\n\n\nFinally, if you mod a number by a larger number, you’ll get the smaller number back since it’s the remainder:\n\n17 %% 20 # Will return 17\n\n#> [1] 17\n\n\n\n4.1.3 Tricks with %% and %/%\n\nThe %% and %/% operators can be really handy. Here are a few tricks.\n\n4.1.3.1 Odds and evens with n %% 2\n\nYou can tell if an integer n is even or odd by using m %% 2. If the result is 0, n must be even (because 2 goes in evenly to even numbers with no remainder). If n is odd, you’ll get a remainder of 1. Here’s an example:\n\n10 %% 2 # Even\n\n#> [1] 0\n\n11 %% 2 # Odd\n\n#> [1] 1\n\n\nThis trick also works with negative numbers!\n\n-42 %% 2 # Even\n\n#> [1] 0\n\n-43 %% 2 # Odd\n\n#> [1] 1\n\n\n\n4.1.4 Number “chopping” with 10s\nWhen you use the mod operator %% on a positive number with factors of 10, it “chops” the number and returns everything to the right of the “chop” point:\n\n123456 %% 1 # Chops to the right of the *ones* digit\n\n#> [1] 0\n\n123456 %% 10 # Chops to the right of the *tens* digit\n\n#> [1] 6\n\n123456 %% 100 # Chops to the right of the *hundreds* digit\n\n#> [1] 56\n\n\nInteger division %/% works the same way, except it returns everything to the left of the “chop” point:\n\n123456 %/% 1 # \"Chops to the right of the ones digit\n\n#> [1] 123456\n\n123456 %/% 10 # \"Chops to the right of the tens digit\n\n#> [1] 12345\n\n123456 %/% 100 # \"Chops to the right of the hundreds digit\n\n#> [1] 1234\n\n\nThis trick works with non-integers too!\n\n3.1415 %% 1\n\n#> [1] 0.1415\n\n3.1415 %/% 1\n\n#> [1] 3\n\n\nBut be careful - this “trick” only works with positive numbers:\n\n-123.456 %% 10\n\n#> [1] 6.544\n\n-123.456 %/% 10\n\n#> [1] -13\n\n\nHere’s some mental notes to remember how this works:\n\n\n%% returns everything to the right (<chop> ->)\n\n%/% returns everything to the left (<- <chop>)\nThe “chop” point is always just to the right of the chopping digit:\n\n\n\n\nExample\n“Chop” point\n“Chop” point description\n\n\n\n1234 %% 1\n1234 |\nRight of the 1’s digit\n\n\n1234 %% 10\n123 | 4\nRight of the 10’s digit\n\n\n1234 %% 100\n12 | 34\nRight of the 100’s digit\n\n\n1234 %% 1000\n1 | 234\nRight of the 1,000’s digit\n\n\n1234 %% 10000\n| 1234\nRight of the 10,000’s digit"
  },
  {
    "objectID": "operators-data-types.html#comparing-things-in-r",
    "href": "operators-data-types.html#comparing-things-in-r",
    "title": "4  Operators & Data Types",
    "section": "\n4.2 Comparing things in R",
    "text": "4.2 Comparing things in R\nOther than simple arithmetic, another common programming task is to compare different values to see if one is greater than, less than, or equal to the other. R handles comparisons with relational and logical operators."
  },
  {
    "objectID": "operators-data-types.html#comparing-two-things",
    "href": "operators-data-types.html#comparing-two-things",
    "title": "4  Operators & Data Types",
    "section": "\n4.3 Comparing two things",
    "text": "4.3 Comparing two things\nTo compare two things, use the following relational operators:\n\nLess than: <\n\nLess than or equal to : <=\n\nGreater than or equal to: >=\n\nGreater than: >\n\nEqual: ==\n\nNot equal: !=\n\n\nThe less than operator < can be used to test whether one number is smaller than another number:\n\n2 < 5\n\n#> [1] TRUE\n\n\nIf the two values are equal, the < operator will return FALSE, while the <= operator will return TRUE: :\n\n2 < 2\n\n#> [1] FALSE\n\n2 <= 2\n\n#> [1] TRUE\n\n\nThe “greater than” (>) and “greater than or equal to” (>=) operators work the same way but in reverse:\n\n2 > 5\n\n#> [1] FALSE\n\n2 > 2\n\n#> [1] FALSE\n\n2 >= 2\n\n#> [1] TRUE\n\n\nTo assess whether two values are equal, we have to use a double equal sign (==):\n\n(2 + 2) == 4\n\n#> [1] TRUE\n\n(2 + 2) == 5\n\n#> [1] FALSE\n\n\nTo assess whether two values are not equal, we have to use an exclamation point sign with an equal sign (!=):\n\n(2 + 2) != 4\n\n#> [1] FALSE\n\n(2 + 2) != 5\n\n#> [1] TRUE\n\n\nIt’s worth noting that you can also apply equality operations to “strings,” which is the general word to describe character values (i.e. not numbers). For example, R understands that a \"penguin\" is a \"penguin\" so you get this:\n\n\"penguin\" == \"penguin\"\n\n#> [1] TRUE\n\n\nHowever, R is very particular about what counts as equality. For two pieces of text to be equal, they must be precisely the same:\n\n\"penguin\" == \"PENGUIN\"        # FALSE because the case is different\n\n#> [1] FALSE\n\n\"penguin\" == \"p e n g u i n\"  # FALSE because the spacing is different\n\n#> [1] FALSE\n\n\"penguin\" == \"penguin \"       # FALSE because there's an extra space on the second string\n\n#> [1] FALSE"
  },
  {
    "objectID": "operators-data-types.html#making-multiple-comparisons",
    "href": "operators-data-types.html#making-multiple-comparisons",
    "title": "4  Operators & Data Types",
    "section": "\n4.4 Making multiple comparisons",
    "text": "4.4 Making multiple comparisons\nTo make a more complex comparison of more than just two things, use the following logical operators:\n\nAnd: &\n\nOr: |\n\nNot: !\n\n\nAnd:\nA logical expression x & y is TRUE only if both x and y are TRUE.\n\n(2 == 2) & (2 == 3) # FALSE because the second comparison if not TRUE\n\n#> [1] FALSE\n\n\n\n(2 == 2) & (3 == 3) # TRUE because both comparisons are TRUE\n\n#> [1] TRUE\n\n\nOr:\nA logical expression x | y is TRUE if either x or y are TRUE.\n\n(2 == 2) | (2 == 3) # TRUE because the first comparison is TRUE\n\n#> [1] TRUE\n\n\nNot:\nThe ! operator behaves like the word “not” in everyday language. If a statement is “not true”, then it must be “false”. Perhaps the simplest example is\n\n!TRUE\n\n#> [1] FALSE\n\n\nIt is good practice to include parentheses to clarify the statement or comparison being made. Consider the following example:\n\n!3 == 5\n\n#> [1] TRUE\n\n\nThis returns TRUE, but it’s a bit confusing. Reading from left to right, you start by saying “not 3”…what does that mean?\nWhat is really going on here is R first evaluates whether 3 is equal to 5 (3 == 5), and then returns the “not” (!) of that. A better version of the same thing would be:\n\n!(3 == 5)\n\n#> [1] TRUE\n\n\n\n4.4.1 Order of operations\nR follows the typical BEDMAS order of operations. That is, R evaluates statements in this order1:\n\n\nBrackets\n\nExponents\n\nDivision\n\nMultiplication\n\nAddition\n\nSubtraction\n\nFor example, if I type:\n\n1 + 2 * 4\n\n#> [1] 9\n\n\nR first computes 2 * 4 and then adds 1. If what you actually wanted was for R to first add 2 to 1, then you should have added parentheses around 1 and 2:\n\n(1 + 2) * 4\n\n#> [1] 12\n\n\nA helpful rule of thumb to remember is that brackets always come first. So, if you’re ever unsure about what order R will do things in, an easy solution is to enclose the thing you want it to do first in brackets.\n\nNote that for logical operators, the order precedence is ! > & > |\n\nFor example, consider the following statement:\n\nTRUE | FALSE & FALSE\n\n#> [1] TRUE\n\n\nThis returns TRUE because the & statement (FALSE & FALSE) is evaluated first, so the whole statement simplifies to TRUE | FALSE, which returns TRUE. If you put parentheses around the | statement, it would evaluate first and the whole statement would return FALSE:\n\n(TRUE | FALSE) & FALSE\n\n#> [1] FALSE\n\n\nSimilarly, consider the following statement:\n\n! TRUE | TRUE\n\n#> [1] TRUE\n\n\nThis returns TRUE because the ! statement is evaluated first (! TRUE is FALSE), and the simplified statement FALSE | TRUE returns TRUE. Again, if you put parentheses around the | statement the whole statement becomes FALSE:\n\n! (TRUE | TRUE)\n\n#> [1] FALSE"
  },
  {
    "objectID": "operators-data-types.html#data-types",
    "href": "operators-data-types.html#data-types",
    "title": "4  Operators & Data Types",
    "section": "\n4.5 Data types",
    "text": "4.5 Data types\nEvery programming language has the ability to store data of different types. R recognizes several important basic data types (there are others, but these cover most cases):\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\n\ndouble\nNumber with a decimal place (aka “float”)\n\n3.14, 1.61803398875\n\n\n\ninteger\nNumber without a decimal place\n\n1, 42\n\n\n\ncharacter\nText in quotes (aka “string”)\n\n\"this is some text\", \"3.14\"\n\n\n\nlogical\nTrue or False (for comparing things)\n\nTRUE, FALSE\n\n\n\n\nIf you want to check with type a value is, you can use the function typeof(). For example:\n\ntypeof(\"hello\")\n\n#> [1] \"character\"\n\n\n\n4.5.1 Numeric types\nNumbers in R have the numeric data type, which is also the default computational type. There are two types of numbers:\n\nIntegers\n\nNon-integers (aka “double” or “float”)\n\nThe difference is that integers don’t have decimal values. A non-integer in R has the type “double”:\n\ntypeof(3.14)\n\n#> [1] \"double\"\n\n\nBy default, R assumes all numbers have a decimal place, even if it looks like an integer:\n\ntypeof(3)\n\n#> [1] \"double\"\n\n\nIn this case, R assumes that 3 is really 3.0. To make sure R knows you really do mean to create an integer, you have to add an L to the end of the number2:\n\ntypeof(3L)\n\n#> [1] \"integer\"\n\n\n\n4.5.2 Character types\nA character value is used to represent string values in R. Anything put between single quotes ('') or double quotes (\"\") will be stored as a character. For example:\n\ntypeof('3')\n\n#> [1] \"character\"\n\n\nNotice that even though the value looks like a number, because it is inside quotes R interprets it as a character. If you mistakenly thought it was a a number, R will gladly return an error when you try to do a numerical operation with it:\n\n'3' + 7\n\n#> Error in \"3\" + 7: non-numeric argument to binary operator\n\n\nIt doesn’t mattef if you use single or double quotes to create a character. The only time is does matter is if the character is a quote symbole itself. For example, if you wanted to type the word \"don't\", you should use double quotes so that R knows the single quote is part of the character:\n\ntypeof(\"don't\")\n\n#> [1] \"character\"\n\n\nIf you used single quotes, you’ll get an error because R reads 'don' as a character:\n\ntypeof('don't')\n\n#> Error: <text>:1:13: unexpected symbol\n#> 1: typeof('don't\n#>                 ^\n\n\nWe will go into much more detail about working with character values later on in Week 7.\n\n4.5.3 Logical types\nLogical data only have two values: TRUE or FALSE. Note that these are not in quotes and are in all caps.\n\ntypeof(TRUE)\n\n#> [1] \"logical\"\n\ntypeof(FALSE)\n\n#> [1] \"logical\"\n\n\nR uses these two special values to help answer questions about logical statements. For example, let’s compare whether 1 is greater than 2:\n\n1 > 2\n\n#> [1] FALSE\n\n\nR returns the values FALSE because 1 is not greater than 2. If I flip the question to whether 1 is less than 2, I’ll get TRUE:\n\n1 < 2\n\n#> [1] TRUE\n\n\n\n4.5.4 Special values\nIn addition to the four main data types mentioned, there are a few additional “special” types: Inf, NaN, NA and NULL.\nInfinity: Inf corresponds to a value that is infinitely large (or infinitely small with -Inf). The easiest way to get Inf is to divide a positive number by 0:\n\n1/0\n\n#> [1] Inf\n\n\nNot a Number: NaN is short for “not a number”, and it’s basically a reserved keyword that means “there isn’t a mathematically defined number for this.” For example:\n\n0/0\n\n#> [1] NaN\n\n\nNot available: NA indicates that the value that is “supposed” to be stored here is missing. We’ll see these much more when we start getting into data structures like vectors and data frames.\nNo value: NULL asserts that the variable genuinely has no value whatsoever, or does not even exist."
  },
  {
    "objectID": "operators-data-types.html#page-sources",
    "href": "operators-data-types.html#page-sources",
    "title": "4  Operators & Data Types",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nDanielle Navarro’s book “Learning Statistics With R”\n\nJenny Bryan’s STAT 545 Course\n\nRStudio primers\nXiao Ping Song’s Intro2R crash course"
  },
  {
    "objectID": "creating-functions.html#basic-syntax",
    "href": "creating-functions.html#basic-syntax",
    "title": "5  Creating Functions",
    "section": "\n5.1 Basic syntax",
    "text": "5.1 Basic syntax\nHere’s the syntax that you use to create a function:\nFNAME <- function(ARG1, ARG2, ETC) {\n  STATEMENT1\n  STATEMENT2\n  return(VALUE)\n}\nWhat this does is create a function with the name FNAME, which has arguments ARG1, ARG2, etc. Whenever the function is called, R executes the statements within the curly braces {}, and then returns the VALUE inside the return() statement.\nThere’s a lot of different pieces to making a function. The way I like to remember how they all go together is to read the following English sentence:\n\n“function name” is a function of () that does…\n\nEach piece of the above sentence corresponds with a piece of code for writing a function:\n\n\n\n\n\n\n\n\n\n“function name”\nis a\nfunction\nof ()\nthat does…\n\n\nFNAME\n<-\nfunction\n(ARG1, ARG2, ETC)\n{}\n\n\nAll the commands your function will execute go in the {}.\nFor example, here’s the function mySqrt(n), which returns the square root of n:\n\n\n\n\n\n\n\n\n\n“function name”\nis a\nfunction\nof ()\nthat does…\n\n\nmySqrt\n<-\nfunction\n(n)\n{ return(n^0.5) }\n\n\nAnd here’s mySqrt(n) written in the typical format:\n\nmySqrt <- function(n) {\n    return(n^0.5)\n}"
  },
  {
    "objectID": "creating-functions.html#arguments",
    "href": "creating-functions.html#arguments",
    "title": "5  Creating Functions",
    "section": "\n5.2 Arguments",
    "text": "5.2 Arguments\nHere’s a function with one argument:\n\nsquare <- function(x) {\n  y <- x^2\n  return(y)\n}\n\n\nsquare(2)\n\n#> [1] 4\n\nsquare(8)\n\n#> [1] 64\n\n\nHere’s a function with multiple arguments:\n\nsumTwoValues <- function(x, y) {\n  value <- x + y\n  return(value)\n}\n\n\nsumTwoValues(2, 3)\n\n#> [1] 5\n\nsumTwoValues(3, 4)\n\n#> [1] 7\n\n\nFunctions don’t always have to take arguments. For example:\n\ndoSomething <- function() {\n    cat(\"Carpe diem!\") # The cat() function prints whatever's inside it to the console\n}\n\n\ndoSomething()\n\n#> Carpe diem!\n\n\nDefault arguments:\nSometimes, a function has a parameter that has a natural default. We can specify that default value in the function definition, then choose whether or not to include it in the function call:\n\nf <- function(x, y=10) {\n    return(x + y)\n}\n\n\nf(5)     # 15\n\n#> [1] 15\n\nf(5, 1)  # 6\n\n#> [1] 6"
  },
  {
    "objectID": "creating-functions.html#the-return-statement",
    "href": "creating-functions.html#the-return-statement",
    "title": "5  Creating Functions",
    "section": "\n5.3 The return() statement",
    "text": "5.3 The return() statement\nHere’s a basic example of using return() to return a value:\n\nisPositive <- function(x) {\n    return (x > 0)\n}\n\n\nisPositive(5)  # TRUE\n\n#> [1] TRUE\n\nisPositive(-5) # FALSE\n\n#> [1] FALSE\n\nisPositive(0)  # FALSE\n\n#> [1] FALSE\n\n\nThe return() statement ends the function immediately:\n\nisPositive <- function(x) {\n    cat(\"Hello!\")   # Runs\n    return(x > 0)\n    cat(\"Goodbye!\") # Does not run (\"dead code\")\n}\n\n\nx <- isPositive(5)  # Prints Hello, then assigns TRUE to x\n\n#> Hello!\n\nx\n\n#> [1] TRUE\n\n\nNotice that in the above example, the cat(\"Goodbye!\") statement is ignored.\nIf you don’t include a return() statement, R will return the value of the last statement by default (Don’t do this):\n\nf <- function(x) {\n    x + 42\n}\n\n\nf(5)\n\n#> [1] 47\n\n\n\nf <- function(x) {\n    x + 42\n    x + 7\n}\n\n\nf(5)\n\n#> [1] 12"
  },
  {
    "objectID": "creating-functions.html#the-cat-statement",
    "href": "creating-functions.html#the-cat-statement",
    "title": "5  Creating Functions",
    "section": "\n5.4 The cat() statement",
    "text": "5.4 The cat() statement\nThe cat() (short for “concatenating”) statement prints whatever arguments it is given to the console. The arguments can be of mixed types and it will convert them all to a concatenated string:\n\nprintX <- function(x) {\n  cat(\"The value of x provided is\", x)\n}\n\n\nprintX(7)\n\n#> The value of x provided is 7\n\nprintX(42)\n\n#> The value of x provided is 42\n\n\nMixing up return() and cat() is a common early mistake. For example:\n\ncubed <- function(x) {\n    cat(x^3)\n}\n\n\ncubed(2)   # Seems to work\n\n#> 8\n\n2*cubed(2) # Expected 16...didn't work\n\n#> 8\n\n\n#> numeric(0)\n\n\nHere’s a correct version:\n\ncubed <- function(x) {\n    return(x^3) # That's better!\n}\n\n\ncubed(2)   # Works!\n\n#> [1] 8\n\n2*cubed(2) # Works!\n\n#> [1] 16"
  },
  {
    "objectID": "creating-functions.html#helper-functions",
    "href": "creating-functions.html#helper-functions",
    "title": "5  Creating Functions",
    "section": "\n5.5 Helper functions",
    "text": "5.5 Helper functions\nIt is often useful to break down more complicated problems into smaller “helper functions”. These helpers can be called in other functions. Here’s an example of using the helper functions square() and squareRoot() to compute the hypotenuse of a triangle:\n\nsquare <- function(x) {\n   return(x^2)\n}\n\nsquareRoot <- function(x) {\n   return(x^0.5)\n}\n\nhypotenuse <- function(a, b) {\n   return(squareRoot(square(a) + square(b)))\n}\n\na = 3\nb = 4\nhypotenuse(a, b)\n\n#> [1] 5"
  },
  {
    "objectID": "creating-functions.html#local-vs.-global-variables",
    "href": "creating-functions.html#local-vs.-global-variables",
    "title": "5  Creating Functions",
    "section": "\n5.6 Local vs. global variables",
    "text": "5.6 Local vs. global variables\nAll variables inside a function are called “local” variables and will NOT be created in the working environment. They can only be used locally within the function. For example:\n\nminSquared <- function(x, y) {\n    smaller = min(x, y)\n    return(smaller^2)\n}\n\n\nminSquared(3, 4)\n\n#> [1] 9\n\nminSquared(4, 3)\n\n#> [1] 9\n\n\nIf you try to call a local variable in the global environment, you’ll get an error:\n\nsquare <- function(x) {\n  y <- x^2\n  return(y)\n}\ny\n\n#> Error in eval(expr, envir, enclos): object 'y' not found\n\n\n“Global” variables are those in the global environment. These will show up in the “Environment” pane in RStudio. You can call these inside functions, but this is BAD practice. Here’s an example (Don’t do this!):\n\nprintN <- function() {\n    cat(n)  # n is not local -- so it is global (bad idea!!!)\n}\nprintN() # Nothing happens because n isn't defined\n\n\nn = 5 # Define n in the global environment\nprintN()\n\n#> 5"
  },
  {
    "objectID": "creating-functions.html#tips",
    "href": "creating-functions.html#tips",
    "title": "5  Creating Functions",
    "section": "\n5.7 Tips",
    "text": "5.7 Tips\nOne particularly useful function is almostEqual():\n\nalmostEqual <- function(d1, d2) {\n    epsilon = 0.00001\n    return(abs(d1-d2) <= epsilon)\n}\n\nThis is useful when comparing numbers that are stored as floats and have lots of trailing zeros. For example, let’s do some simple addition:\n\nx <- 0.1 + 0.2\nx\n\n#> [1] 0.3\n\n\nIf we compared x to 0.3, we would expect the result to be TRUE, right?\n\nx == 0.3\n\n#> [1] FALSE\n\n\nWhat went wrong here? Well, what looks like a value of 0.3 is actually a float with a lot of zeros:\n\nprint(x, digits = 20)\n\n#> [1] 0.30000000000000004441\n\n\nBy default, R doesn’t print out all these zeros, but they are the result of many small rounding errors that occur when computers do calculations.\nThis is where almostEqual() comes in handy:\n\nalmostEqual(x, 0.3)\n\n#> [1] TRUE\n\n\nIt only compares numbers out to a predefined decimal place, after which it ignores everything else. This will come in handy in your homework problems where you might get unexpected results."
  },
  {
    "objectID": "creating-functions.html#page-sources",
    "href": "creating-functions.html#page-sources",
    "title": "5  Creating Functions",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers\n\nDanielle Navarro’s website “R for Psychological Science”"
  },
  {
    "objectID": "conditionals.html#if",
    "href": "conditionals.html#if",
    "title": "6  Conditionals",
    "section": "\n6.1 if",
    "text": "6.1 if\nThe basic format of an if statement in R is as follows:\nif ( CONDITION ) {\n    STATEMENT1\n    STATEMENT2\n    ETC\n}\nIf the condition is TRUE, then R will execute the statements contained in the curly braces, otherwise it will skip it. This schematic illustrates the idea:\n\n\n\nExample 1\n\nf <- function(x) {\n    cat(\"A\")\n    if (x == 0) {\n        cat(\"B\")\n        cat(\"C\")\n    }\n    cat(\"D\")\n}\n\n\nf(0)\n\n#> ABCD\n\nf(1)\n\n#> AD\n\n\nExample 2\nConsider a simple absolute value function. Since abs() is a built-in function, we’ll call ours absValue():\n\nabsValue <- function(x) {\n    if (x < 0) {\n        x = -1*x\n    }\n    return(x)\n}\n\n\nabsValue(7)  # Returns 7\n\n#> [1] 7\n\nabsValue(-7) # Also returns 7\n\n#> [1] 7"
  },
  {
    "objectID": "conditionals.html#if-else",
    "href": "conditionals.html#if-else",
    "title": "6  Conditionals",
    "section": "\n6.2 if else",
    "text": "6.2 if else\nYou can extend the if statement to include an else statement as well, leading to the following syntax:\nif ( CONDITION ) {\n  STATEMENT1\n  STATEMENT2\n  ETC\n} else {\n  STATEMENT3\n  STATEMENT4\n  ETC\n}\nThe interpretation of this version is similar. If the condition is TRUE, then the contents of the first block of code are executed; but if it is FALSE, then the contents of the second block of code are executed instead. The schematic illustration of an if-else construction looks like this:\n\n\n\nExample\n\nf <- function(x) {\n    cat(\"A\")\n    if (x == 0) {\n        cat(\"B\")\n        cat(\"C\")\n    }\n    else {\n        cat(\"D\")\n        if (x == 1) {\n            cat(\"E\")\n        } else {\n            cat(\"F\")\n        }\n    }\n    cat(\"G\")\n}\n\n\nf(0)\n\n#> ABCG\n\nf(1)\n\n#> ADEG\n\nf(2)\n\n#> ADFG"
  },
  {
    "objectID": "conditionals.html#else-if",
    "href": "conditionals.html#else-if",
    "title": "6  Conditionals",
    "section": "\n6.3 else if",
    "text": "6.3 else if\nYou can also chain multiple else if statements together for a more complex conditional statement. For example, if you’re trying to assign letter grades to a numeric test score, you can use a series of else if statements to search for the bracket the score lies in:\n\ngetLetterGrade <- function(score) {\n    if (score >= 90) {\n        grade = \"A\"\n    } else if (score >= 80) {\n        grade = \"B\"\n    } else if (score >= 70) {\n        grade = \"C\"\n    } else if (score >= 60) {\n        grade = \"D\"\n    } else {\n        grade = \"F\"\n    }\n    return(grade)\n}\n\n\ncat(\"103 -->\", getLetterGrade(103))\n\n#> 103 --> A\n\ncat(\" 88 -->\", getLetterGrade(88))\n\n#>  88 --> B\n\ncat(\" 70 -->\", getLetterGrade(70))\n\n#>  70 --> C\n\ncat(\" 61 -->\", getLetterGrade(61))\n\n#>  61 --> D\n\ncat(\" 22 -->\", getLetterGrade(22))\n\n#>  22 --> F"
  },
  {
    "objectID": "conditionals.html#page-sources",
    "href": "conditionals.html#page-sources",
    "title": "6  Conditionals",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers\n\nDanielle Navarro’s website “R for Psychological Science”"
  },
  {
    "objectID": "testing-debugging.html#writing-test-cases",
    "href": "testing-debugging.html#writing-test-cases",
    "title": "7  Testing & Debugging",
    "section": "\n7.1 Writing test cases",
    "text": "7.1 Writing test cases\n\n\n\nWriting test cases is part of the process of understanding a problem; if you don’t know what the result of an example input should be, you can’t know how to solve the problem.\nTest cases are also used to verify that a solution to a problem is correct – that it works as expected. Without a good set of test cases, we have no idea whether our code actually works!\n\n7.1.1 Test case types\nTest cases vary based on the problem, but you generally want to ensure that you have at least one or two of each of the following test case types:\n\n\nNormal Cases: Typical input that should follow the main path through the code.\n\nLarge Cases: Typical input, but of a larger size than usual. This ensures that bugs don’t appear after multiple iterations.\n\nEdge Cases: Pairs of inputs that test different choice points in the code. For example, if a condition in the problem checks whether n < 2, two important edge cases are when n = 2 and n = 3, which trigger different behaviors. Other edge cases include the first / last characters in a string or items in a list.\n\nSpecial Cases: Some inputs need to be special-cased for many problems. This includes negative numbers, 0 and 1 for integers, the empty string (\"\"), and input values of different types than are expected.\n\nVarying Results: Finally, test cases should cover multiple possible results. This is especially important for logical functions; make sure that you have both TRUE and FALSE cases among your tests!\n\n7.1.2 Testing with stopifnot()\n\nThe stopifnot() function does what you might expect - it stops the function if whatever is inside the () is not TRUE. Let’s look at an example.\nConsider the function isEvenNumber(), which takes a numeric value and returns TRUE if it is an even number and FALSE otherwise:\n\nisEvenNumber <- function(n) {\n    # A number is \"even\" if it is divisible by 2 with no remainder\n    remainder <- n %% 2\n    return(remainder == 0)\n}\n\nHere is a simple test function for isEvenNumber() that uses the stopifnot() function to examine the following two test cases:\n\nWe expect the output of isEvenNumber(42) to be TRUE\n\nWe expect the output of isEvenNumber(43) to be FALSE\n\n\n\ntestIsEvenNumber <- function() {\n    cat(\"Testing isEvenNumber()... \")\n    stopifnot(isEvenNumber(42) == TRUE)\n    stopifnot(isEvenNumber(43) == FALSE)\n    cat(\"Passed!\\n\")\n}\n\nIn this test function, we called the stopifnot() function and used the == operator to assess whether the output of isEvenNumber() is equal to the value we expected. We can run these cases by simply calling our test function:\n\ntestIsEvenNumber()\n\n#> Testing isEvenNumber()... Passed!\n\n\n\n7.1.3 Testing function inputs\nThe two test cases we used for isEvenNumber() are “normal” cases because they use typical inputs and test for expected outputs. A better test function would also include a few other statements to test other points of failure.\nOne particular common error is when a user inputs the wrong data type to a function:\n\nisEvenNumber('42')\n\n#> Error in n%%2: non-numeric argument to binary operator\n\n\nHere we’ve input a string instead of a number, and R sent us an error message. To account for this possibility, we can modify our function and test function:\n\nisEvenNumber <- function(n) {\n    # First make sure the input is a numeric type\n    if (! is.numeric(n)) {\n        return(FALSE)\n    }\n    remainder <- n %% 2\n    return(remainder == 0)\n}\n\ntestIsEvenNumber <- function() {\n    cat(\"Testing isEvenNumber()... \")\n    stopifnot(isEvenNumber(42) == TRUE)\n    stopifnot(isEvenNumber(43) == FALSE)\n    stopifnot(isEvenNumber('not_a_number') == FALSE)\n    cat(\"Passed!\\n\")\n}\n\ntestIsEvenNumber()\n\n#> Testing isEvenNumber()... Passed!\n\n\n\n7.1.4 Better error messaging with stop()\n\nAnother approach to checking input types is to explicitly provide a better error message so the user can know what went wrong. For example, rather than return FALSE when we input a string to isEvenNumber(), we can use stop() to halt the function and send an error message:\n\nisEvenNumber <- function(n) {\n    if (! is.numeric(n)) {\n        stop('Oops! This function requires numeric inputs!')\n    }\n    remainder <- n %% 2\n    return(remainder == 0)\n}\nisEvenNumber('42')\n\n#> Error in isEvenNumber(\"42\"): Oops! This function requires numeric inputs!"
  },
  {
    "objectID": "testing-debugging.html#debugging",
    "href": "testing-debugging.html#debugging",
    "title": "7  Testing & Debugging",
    "section": "\n7.2 Debugging",
    "text": "7.2 Debugging\nBugs are a natural part of the programming process. However, you can reduce the number of bugs you encounter by following a few tips:\n\nWrite code with good style.\nWrite tests before writing functions, and test as you go.\nMake sure each function only has one task.\nAvoid copying and pasting code at all costs (this leads to bug propagation).\n\n\n7.2.1 Debugging your own code\nThe most common case you will run into a bug is when writing new code yourself. Often the mistake is obvious and easily fixed, but sometimes it only appears after multiple levels of calls and is harder to diagnose. There are a few common strategies to use when debugging your own code.\n\nUse traceback() to determine where a given error is occurring.\nOutput diagnostic information in code with print(), cat() or message() statements.\nUse browser() to open an interactive debugger before the error\nUse debug() to automatically open a debugger at the start of a function call.\nUse trace() to start a debugger at a location inside a function.\n\n\n7.2.1.1 traceback()\n\nThe traceback() function can be used to print a summary of how your program arrived at the error. This is also called a call stack, stack trace or backtrace.\nIn R this gives you each call that lead up to the error, which can be very useful for determining what lead to the error.\nYou can use traceback() in two different ways, either by calling it immediately after the error has occurred.\n\n\nf <- function(x) {\n    return(x + 1)\n}\ng <- function(x) {\n    return(f(x) - 1)\n}\ng(\"a\")\n\n#> Error in x + 1 : non-numeric argument to binary operator\ntraceback()\n#> 2: f(x) at #1\n#> 1: g(\"a\")\nOr by using traceback() as an error handler, which will call it immediately on any error. (You could even put this in your .Rprofile)\n\noptions(error = traceback)\ng(\"a\")\n\n#> Error in x + 1 : non-numeric argument to binary operator\n#> 2: f(x) at #1\n#> 1: g(\"a\")\n\n7.2.1.2 print()\n\nOnce you know where an error occurs it is then helpful to know why. Often errors occur because functions are given inputs their authors did not expect, so it is useful to print the value of objects during execution.\nThe most basic way to do this is to sprinkle messages throughout your code, with print() or str(). str() is often more useful because it gives more detail into the exact structure of an object, which may not be the structure you expect it to be.\nThe main downsides to the print approach is you often have to add them in multiple places to narrow down the error, and you cannot further investigate the object.\n\n7.2.1.3 browser()\n\nA more sophisticated debugging method is to put a call to browser() in your code. This will stop execution at that point and open R’s interactive debugger. In the debugger you can run any R command to look at objects in the current environment, modify them and continue executing.\nSome useful things to do are\n\nUse ls() to determine what objects are available in the current environment. This allows you to see exactly what things you can examine.\nUse str(), print() etc. to examine the objects\nUse n to evaluate the next statement. Use s to evaluate the next statement, but step into function calls.\nUse where to print a stack trace\n\nUse c to leave the debugger and continue execution\nUse Q to exit the debugger and return to the R prompt.\n\n7.2.2 Debugging in RStudio\n\n7.2.2.1 Editor breakpoints\nRStudio provides some additional tooling for debugging over using R on the command line. First you can set an editor breakpoint by clicking to the left of the line number in the source file, or by pressing Shift+F9 with your cursor on the line. A breakpoint is equivalent to a browser() call, but you avoid needing to change your code like browser().\n\n\n7.2.2.2 Stopping on error\nIf you are trying to hunt down a particular error it is often useful to have RStudio enter the debugger when it occurs. You can control the error behavior with (Debug -> On Error -> Error Inspector).\n\n\n7.2.2.3 Debugging console\n\nThe RStudio debugging console has a few buttons to make debugging a little nicer, From left to right they are, next (equivalent to n), step info (s), continue (c) and Stop (Q)."
  },
  {
    "objectID": "testing-debugging.html#page-sources",
    "href": "testing-debugging.html#page-sources",
    "title": "7  Testing & Debugging",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers\n\nJennifer Bryan & Jim Hester’s “What They Forgot to Teach You About R”"
  },
  {
    "objectID": "iteration.html#the-for-loop",
    "href": "iteration.html#the-for-loop",
    "title": "8  Iteration",
    "section": "\n8.1 The for loop",
    "text": "8.1 The for loop\nUse for loops when there is a known number of iterations. The basic format of a for loop goes like this:\nfor (VALUE in SEQUENCE) {\n  STATEMENT1\n  STATEMENT2\n  ETC\n}\nIn a for loop, R runs a fixed number of iterations determined by the SEQUENCE statement, which is a sequence of values. In each iteration, the variable VALUE will take the next value in SEQUENCE. Once we’ve exhausted all of the values in SEQUENCE, the loop terminates and the flow of the program continues down the script. This schematic illustrates the idea:\n\n\n\n\n8.1.1 Looping over numbers\nIt is common to use a sequence of integers for the values in SEQUENCE. The simplest way to do this is to use the : operator. For example, the code 1:10 creates the integers 1 through 10. The following for loop uses this sequence to print out each integer in the sequence:\n\n# Print the numbers from 1 to 10\nfor (i in 1:10) {\n    print(i)\n}\n\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10\n\n\nYou can also use the seq() function to generate a specific sequence of numbers over which to iterate. This can be useful if you want to control the step size (in the example below, it’s 2):\n\n# Print the numbers from 1 to 10 with a step size of 2\nfor (i in seq(1, 10, by=2)) {\n    print(i)\n}\n\n#> [1] 1\n#> [1] 3\n#> [1] 5\n#> [1] 7\n#> [1] 9\n\n\n\n8.1.2 Looping over other things\nR will loop over any sequence you create. For example, you can loop over a vector of characters (The c() function creates a “vector”…we’ll get to those next lesson):\n\nx <- c('If', 'you', 'want', 'to', 'view', 'paradise,', 'simply', 'look',\n       'around', 'and', 'view', 'it.')\nfor (i in x) {\n    print(i)\n}\n\n#> [1] \"If\"\n#> [1] \"you\"\n#> [1] \"want\"\n#> [1] \"to\"\n#> [1] \"view\"\n#> [1] \"paradise,\"\n#> [1] \"simply\"\n#> [1] \"look\"\n#> [1] \"around\"\n#> [1] \"and\"\n#> [1] \"view\"\n#> [1] \"it.\"\n\n\nYou can also loop over logical values. The following loop will print out the value when it is TRUE:\n\nx <- c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)\nfor (i in x) {\n    if (i == TRUE) {\n      print(i)\n    }\n}\n\n#> [1] TRUE\n#> [1] TRUE\n#> [1] TRUE\n\n\n\n8.1.3 Nested for loops\nYou can have loops inside loops! This is useful when working on things that have more than one dimension. For example, let’s print out a 5 x 5 rectangle out of asterisks (*) by looping over rows and columns:\n\nn <- 5\nfor (row in seq(n)) {\n    for (col in seq(n)) {\n        cat(\"*\")\n    }\n    cat('\\n') # Print a new line\n}\n\n#> *****\n#> *****\n#> *****\n#> *****\n#> *****\n\n\nThis will come in handy when working with 2-dimensional objects like data frames."
  },
  {
    "objectID": "iteration.html#the-while-loop",
    "href": "iteration.html#the-while-loop",
    "title": "8  Iteration",
    "section": "\n8.2 The while loop",
    "text": "8.2 The while loop\n\nA friend calls her programmer roommate and says, “while you’re out, buy some milk”…her roommate never returned home.\n\n\nUse while loops when there is an indeterminate number of iterations. The basic format of the loop looks like this:\nwhile (CONDITION) {\n  STATEMENT1\n  STATEMENT2\n  ETC\n}\nThe code corresponding to CONDITION needs to produce a logical value, either TRUE or FALSE. Whenever R encounters a while statement, it checks to see if the condition is TRUE. If it is, R goes on to execute all of the commands inside the curly brackets. R will then continue to repeat this process until the condition is FALSE. Once that happens, R jumps to the bottom of the loop (i.e., to the } character), and then continues on with whatever commands appear next in the script. This schematic illustrates the idea:\n\n\n\nExample:\nThe following function prints each power of 2 up to an upper limit:\n\npowersOfTwo <- function(upperLimit) {\n    n = 1\n    while (n < upperLimit) {\n        print(n)\n        n = 2*n\n    }\n}\n\n\npowersOfTwo(5)\n\n#> [1] 1\n#> [1] 2\n#> [1] 4\n\npowersOfTwo(100)\n\n#> [1] 1\n#> [1] 2\n#> [1] 4\n#> [1] 8\n#> [1] 16\n#> [1] 32\n#> [1] 64"
  },
  {
    "objectID": "iteration.html#the-break-and-next-statements",
    "href": "iteration.html#the-break-and-next-statements",
    "title": "8  Iteration",
    "section": "\n8.3 The break and next statements",
    "text": "8.3 The break and next statements\n\n8.3.1 break\n\nYou can force a loop to stop by inserting the break statement in the loop. In a nested loop, the break statement exits from the innermost loop that is being evaluated. Here’s an example:\n\nfor (val in 1:5) {\n    if (val == 3) {\n        break\n    }\n    print(val)\n}\n\n#> [1] 1\n#> [1] 2\n\n\nIn this example, we iterate over the consecutive numbers from 1 to 5. Inside the for loop we have used a if condition to break if the current value is equal to 3. As we can see from the output, the loop terminates when it encounters the break statement.\n\n8.3.2 next\n\nA next statement is useful when we want to skip the current iteration of a loop without terminating it. On encountering next, R will jump to the end of the loop and start the next iteration. Here’s an example:\n\nfor (val in 1:5) {\n    if (val == 3) {\n        next\n    }\n    print(val)\n}\n\n#> [1] 1\n#> [1] 2\n#> [1] 4\n#> [1] 5\n\n\nIn the above example, we use the next statement inside an if statement to check if the value is equal to 3. If the value is equal to 3, the current evaluation stops (i.e. the value is not printed) and the loop continues with the next iteration."
  },
  {
    "objectID": "iteration.html#page-sources",
    "href": "iteration.html#page-sources",
    "title": "8  Iteration",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers\n\nDanielle Navarro’s website “R for Psychological Science”"
  },
  {
    "objectID": "vectors.html#vector-basics",
    "href": "vectors.html#vector-basics",
    "title": "9  Vectors",
    "section": "\n9.1 Vector basics",
    "text": "9.1 Vector basics\n\n9.1.1 Creating vectors\nThe most basic way of creating a vector is to use the c() function (“c” is for “concatenate”):\n\nx <- c(1, 2, 3)\nlength(x)\n\n#> [1] 3\n\n\nAs we saw in the loops lesson, you can also create vectors of sequences using the : operator or the seq() function:\n\nseq(1, 10)\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n1:5\n\n#> [1] 1 2 3 4 5\n\n\nYou can also create a vector by using the rep() function, which replicates the same value n times:\n\ny <- rep(5, 10) # The number 5 ten times\nz <- rep(10, 5) # The number 10 five times\n\n\ny\n\n#>  [1] 5 5 5 5 5 5 5 5 5 5\n\nz\n\n#> [1] 10 10 10 10 10\n\n\nIn fact, you can use the rep() function to create longer vectors made up of repeated vectors:\n\nrep(c(1, 2), 3) # Repeat the vector c(1, 2) three times\n\n#> [1] 1 2 1 2 1 2\n\n\nIf you add the each argument, rep() will repeat each element in the vector:\n\nrep(c(1, 2), each = 3) # Repeat each element of the vector c(1, 2) three times\n\n#> [1] 1 1 1 2 2 2\n\n\nYou can see how long a vector is using the length() function:\n\nlength(y)\n\n#> [1] 10\n\nlength(z)\n\n#> [1] 5\n\n\n\n9.1.2 Vector coercion\nEach element in a vector must have the same type. If you mix types in a vector, R will coerce all the elements to either a numeric or character type.\nIf a vector has a single character element, R makes everything a character:\n\nc(1, 2, \"3\")\n\n#> [1] \"1\" \"2\" \"3\"\n\nc(TRUE, FALSE, \"TRUE\")\n\n#> [1] \"TRUE\"  \"FALSE\" \"TRUE\"\n\n\nIf a vector has numeric and logical elements, R makes everything a number:\n\nc(1, 2, TRUE, FALSE)\n\n#> [1] 1 2 1 0\n\n\nIf a vector has integers and floats, R makes everything a float:\n\nc(1L, 2, pi)\n\n#> [1] 1.000000 2.000000 3.141593\n\n\n\n9.1.3 Deleting vectors\nYou can delete a vector by assigning NULL to it:\n\nx <- seq(1, 10)\nx\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\nx <- NULL\nx\n\n#> NULL\n\n\n\n9.1.4 Numeric vectors\nAs we saw in the loops lesson, you can create a vector of integers using the : operator or the seq() function:\n\n1:10\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10)\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNumeric vectors don’t all have to be integers though - they can be any number:\n\nv <- c(pi, 7, 42, 365)\nv\n\n#> [1]   3.141593   7.000000  42.000000 365.000000\n\ntypeof(v)\n\n#> [1] \"double\"\n\n\nR has many built-in functions that are designed to give summary information about numeric vectors. Note that these functions take a vectors of numbers and return single values. Here are some common ones:\n\n\n\n\n\n\n\nFunction\nDescription\nExample\n\n\n\nmean(x)\nMean of values in x\n\n\nmean(c(1,2,3,4,5)) returns 3\n\n\n\nmedian(x)\nMedian of values in x\n\n\nmedian(c(1,2,2,4,5)) returns 2\n\n\n\nmax(x)\nMax element in x\n\n\nmax(c(1,2,3,4,5)) returns 5\n\n\n\nmin(x)\nMin element in x\n\n\nmin(c(1,2,3,4,5)) returns 1\n\n\n\nsum(x)\nSums the elements in x\n\n\nsum(c(1,2,3,4,5)) returns 15\n\n\n\nprod(x)\nProduct of the elements in x\n\n\nprod(c(1,2,3,4,5)) returns 120\n\n\n\n\n9.1.5 Character vectors\nCharacter vectors are vectors where each element is a string:\n\nstringVector <- c('oh', 'what', 'a', 'beautiful', 'morning')\nstringVector\n\n#> [1] \"oh\"        \"what\"      \"a\"         \"beautiful\" \"morning\"\n\ntypeof(stringVector)\n\n#> [1] \"character\"\n\n\nAs we’ll see in the next lesson on strings, you can “collapse” a character vector into a single string using the str_c() function from the stringr library:\n\nlibrary(stringr)\nstr_c(stringVector, collapse = ' ')\n\n#> [1] \"oh what a beautiful morning\"\n\n\n\n9.1.6 Logical vectors\nLogical vectors contain only TRUE or FALSE elements:\n\nlogicalVector <- c(rep(TRUE, 3), rep(FALSE, 3))\nlogicalVector\n\n#> [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n\nIf you add a numeric type to a logical vector, the logical elements will be converted to either a 1 for TRUE or 0 for FALSE:\n\nc(logicalVector, 42)\n\n#> [1]  1  1  1  0  0  0 42\n\n\nWarning: If you add a character type to a logical vector, the logical elements will be converted to strings of \"TRUE\" and \"FALSE\". So even though they may still look like logical types, they aren’t:\n\ny <- c(logicalVector, 'string')\ny\n\n#> [1] \"TRUE\"   \"TRUE\"   \"TRUE\"   \"FALSE\"  \"FALSE\"  \"FALSE\"  \"string\"\n\ntypeof(y)\n\n#> [1] \"character\"\n\n\n\n9.1.7 Comparing vectors\nIf you want to check if two vectors are identical (in that they contain all the same elements), you can’t use the typical == operator by itself. The reason is because the == operator is performed element-wise, so it will return a logical vector:\n\nx <- c(1,2,3)\ny <- c(1,2,3)\nx == y\n\n#> [1] TRUE TRUE TRUE\n\n\nInstead of getting one TRUE, you get a vector of TRUEs, because the individual elements are indeed equal. To compare if all the elements in the two vectors are identical, wrap the comparison inside the all() function:\n\nall(x == y)\n\n#> [1] TRUE\n\n\nKeep in mind that there are really two steps going on here: 1) x == y creates a logical vectors of TRUE’s and FALSE’s based on element-wise comparisons, and 2) the all() function compares whether all of the values in the logical vector are TRUE.\nYou can also use the all() function to compare if other types of conditions are all TRUE for all elements in two vectors:\n\na <- c(1,2,3)\nb <- -1*c(1,2,3)\nall(a > b)\n\n#> [1] TRUE\n\n\nIn contrast to the all() function, the any() function will return TRUE if any of the elements in a vector are TRUE:\n\na <- c(1,2,3)\nb <- c(-1,2,-3)\na == b\n\n#> [1] FALSE  TRUE FALSE\n\nany(a == b)\n\n#> [1] TRUE\n\n\nFor most situations, the all() function works just fine for comparing vectors, but it only compares the elements in the vectors, not their attributes. In some situations, you might also want to check if the attributes of vector, such as their names and data types, are also the same. In this case, you should use the identical() function.\n\nnames(x) <- c('a', 'b', 'c')\nnames(y) <- c('one', 'two', 'three')\nall(x == y) # Only compares the elements\n\n#> [1] TRUE\n\nidentical(x, y) # Also compares the **names** of the elements\n\n#> [1] FALSE\n\n\nNotice that for the identical() function, you don’t need to add a conditional statement - you just provide it the two vectors you want to compare. This is because identical() by definition is comparing if two things are the same."
  },
  {
    "objectID": "vectors.html#accessing-elements-in-a-vector",
    "href": "vectors.html#accessing-elements-in-a-vector",
    "title": "9  Vectors",
    "section": "\n9.2 Accessing elements in a vector",
    "text": "9.2 Accessing elements in a vector\nYou can access elements from a vector using brackets [] and indices inside the brackets. You can use integer indices (probably the most common way), character indices (by naming each element), and logical indices.\n\n9.2.1 Using integer indices\nVector indices start from 1 (this is important - most programming languages start from 0):\n\nx <- seq(1, 10)\nx[1] # Returns the first element\n\n#> [1] 1\n\nx[3] # Returns the third element\n\n#> [1] 3\n\nx[length(x)] # Returns the last element\n\n#> [1] 10\n\n\nYou can access multiple elements by using a vector of indices inside the brackets:\n\nx[c(1:3)]  # Returns the first three elements\n\n#> [1] 1 2 3\n\nx[c(2, 7)] # Returns the 2nd and 7th elements\n\n#> [1] 2 7\n\n\nYou can also use negative integers to remove elements, which returns all elements except that those specified:\n\nx[-1] # Returns everything except the first element\n\n#> [1]  2  3  4  5  6  7  8  9 10\n\nx[-c(2, 7)] # Returns everything except the 2nd and 7th elements\n\n#> [1]  1  3  4  5  6  8  9 10\n\n\nBut you cannot mix positive and negative integers while indexing:\n\nx[c(-2, 7)]\n\n#> Error in x[c(-2, 7)]: only 0's may be mixed with negative subscripts\n\n\nIf you try to use a float as an index, it gets rounded down to the nearest integer:\n\nx[3.1415] # Returns the 3rd element\n\n#> [1] 3\n\nx[3.9999] # Still returns the 3rd element\n\n#> [1] 3\n\n\n\n9.2.2 Using characters indices\nYou can name the elements in a vector and then use those names to access elements. To create a named vector, use the names() function:\n\nx <- seq(5)\nnames(x) <- c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j')\n\n#> Error in names(x) <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"): 'names' attribute [10] must be the same length as the vector [5]\n\nx\n\n#> [1] 1 2 3 4 5\n\n\nYou can also create a named vector by putting the names directly in the c() function:\n\nx <- c('a' = 1, 'b' = 2, 'c' = 3, 'd' = 4, 'e' = 5)\nx\n\n#> a b c d e \n#> 1 2 3 4 5\n\n\nOnce your vector has names, you can then use those names as indices:\n\nx['a'] # Returns the first element\n\n#> a \n#> 1\n\nx[c('a', 'c')] # Returns the 1st and 3rd elements\n\n#> a c \n#> 1 3\n\n\n\n9.2.3 Using logical indices\nWhen using a logical vector for indexing, the position where the logical vector is TRUE is returned. This is helpful for filtering vectors based on conditions:\n\nx <- seq(1, 10)\nx > 5 # Create logical vector\n\n#>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx[x > 5] # Put logical vector in brackets to filter out the TRUE elements\n\n#> [1]  6  7  8  9 10\n\n\nYou can also use the which() function to find the numeric indices for which a condition is TRUE, and then use those indices to select elements:\n\nwhich(x < 5) # Returns indices of TRUE elements\n\n#> [1] 1 2 3 4\n\nx[which(x < 5)] # Use which to select elements based on a condition\n\n#> [1] 1 2 3 4"
  },
  {
    "objectID": "vectors.html#vectorized-operations",
    "href": "vectors.html#vectorized-operations",
    "title": "9  Vectors",
    "section": "\n9.3 Vectorized operations",
    "text": "9.3 Vectorized operations\nMost base functions in R are “vectorized”, meaning that when you give them a vector, they perform the operation on each element in the vector.\n\n9.3.1 Arithmetic operations\nWhen you perform arithmetic operations on vectors, they are executed on an element-by-element basis:\n\nx1 <- c(1, 2, 3)\nx2 <- c(4, 5, 6)\n\n\n# Addition\nx1 + x2 # Returns (1+4, 2+5, 3+6)\n\n#> [1] 5 7 9\n\n# Subtraction\nx1 - x2 # Returns (1-4, 2-5, 3-6)\n\n#> [1] -3 -3 -3\n\n# Multiplicattion\nx1 * x2 # Returns (1*4, 2*5, 3*6)\n\n#> [1]  4 10 18\n\n# Division\nx1 / x2 # Returns (1/4, 2/5, 3/6)\n\n#> [1] 0.25 0.40 0.50\n\n\nWhen performing vectorized operations, the vectors need to have the same dimensions, or one of the vectors needs to be a single-value vector:\n\n# Careful! Mis-matched dimensions will only give you a warning, but will still return a value:\nx1 <- c(1, 2, 3)\nx2 <- c(4, 5)\nx1 + x2\n\n#> Warning in x1 + x2: longer object length is not a multiple of shorter object\n#> length\n\n\n#> [1] 5 7 7\n\n\nWhat R does in these cases is repeat the shorter vector, so in the above case the last value is 3 + 4.\nIf you have a single value vector, R will add it element-wise:\n\nx1 <- c(1, 2, 3)\nx2 <- c(4)\nx1 + x2\n\n#> [1] 5 6 7\n\n\n\n9.3.2 Sorting\nYou can reorder the arrangement of elements in a vector by using the sort() function:\n\na = c(2, 4, 6, 3, 1, 5)\nsort(a)\n\n#> [1] 1 2 3 4 5 6\n\nsort(a, decreasing = TRUE)\n\n#> [1] 6 5 4 3 2 1\n\n\nTo get the index values of the sorted order, use the order() function:\n\norder(a)\n\n#> [1] 5 1 4 2 6 3\n\n\nThese indices tell us that the first value in the sorted arrangement of vector a is element number 5 (which is a 1), the second value is element number 1 (which is a 2), and so on. If you use order() as the indices to the vector, you’ll get the sorted vector:\n\na[order(a)] # Same as sort(a)\n\n#> [1] 1 2 3 4 5 6"
  },
  {
    "objectID": "vectors.html#tips",
    "href": "vectors.html#tips",
    "title": "9  Vectors",
    "section": "\n9.4 Tips",
    "text": "9.4 Tips\n\n9.4.1 Use vectors instead of a loop\nAs we saw in the loops lesson, you can use a loop to perform an operation on each element in a vector. For example, the following loop get the decimal values for each element in a vector of floats:\n\nx <- c(3.1415, 1.618, 2.718)\nremainder <- c()\nfor (i in x) {\n    remainder <- c(remainder, i %% 1)\n}\nremainder\n\n#> [1] 0.1415 0.6180 0.7180\n\n\nYou could achieve the same thing by just performing the operation inside the loop (the i %% 1 bit) on the whole vector:\n\nremainder <- x %% 1\nremainder\n\n#> [1] 0.1415 0.6180 0.7180\n\n\nIn many cases, using a vector can save you a whole lot of code (and time!) by avoiding loops entirely!"
  },
  {
    "objectID": "vectors.html#page-sources",
    "href": "vectors.html#page-sources",
    "title": "9  Vectors",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers\n\nDanielle Navarro’s website “R for Psychological Science”\n\nRStudio primers"
  },
  {
    "objectID": "strings.html#making-a-string",
    "href": "strings.html#making-a-string",
    "title": "10  Strings",
    "section": "\n10.1 Making a string",
    "text": "10.1 Making a string\nYou can create strings with either single quotes ('') or double quotes (\"\"). There is no difference in behavior.\n\ncat(\"This is a string\")\n\n#> This is a string\n\ncat('This is a string')\n\n#> This is a string\n\n\nIf you have a string that contains a ' symbol, use double quotes: Use them where it makes sense, e.g.:\n\ncat(\"It's a boy!\")\n\n#> It's a boy!\n\n\nLikewise, if you have a string that contains a \" symbol, use single quotes: Use them where it makes sense, e.g.:\n\ncat('I said, \"Hi!\"')\n\n#> I said, \"Hi!\"\n\n\nBut what if you have a string that has both single and double quotes, like this: It's nice to say, \"Hi!\"\nIn this case, you have to “escape” the quotes by using the \\ symbol:\n\ncat(\"It's nice to say, \\\"Hi!\\\"\") # Double quotes escaped\n\n#> It's nice to say, \"Hi!\"\n\ncat('It\\'s nice to say, \"Hi!\"') # Single quote escaped\n\n#> It's nice to say, \"Hi!\"\n\n\nEscaping can be used for a lot of different string literals, such as starting a new line, adding a tab space, and even entering the \\ symbol itself:\n\ncat('New line:', 'This\\nthat')\n\n#> New line: This\n#> that\n\ncat('Tab space:', 'This\\tthat')\n\n#> Tab space: This  that\n\ncat('Backslash:', 'This\\\\that')\n\n#> Backslash: This\\that\n\n\nBeware that the printed representation of a string in the R console is not the same as string itself, because the printed representation shows the escapes. To see the raw contents of the string, use cat() or writeLines()."
  },
  {
    "objectID": "strings.html#string-constants",
    "href": "strings.html#string-constants",
    "title": "10  Strings",
    "section": "\n10.2 String constants",
    "text": "10.2 String constants\nR has a small number of built-in string constants: LETTERS, letters, month.abb, and month.name. These are common values stored in variables with convenient names:\n\nLETTERS\n\n#>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\"\n#> [19] \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nletters\n\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\"\n#> [19] \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nmonth.abb\n\n#>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\nmonth.name\n\n#>  [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n#>  [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\"\n\n\nIf you assign-over one of these constants, you can always retrieve the constant by putting the base:: prefix in front:\n\nletters <- 7\nletters\n\n#> [1] 7\n\nletters <- base::letters\nletters\n\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\"\n#> [19] \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nIn addition to the Base R constants, the stringr library also comes with three constants: words, sentences, and fruit. These are much longer, so let’s use the head() function to just preview the first 6 elements in each:\n\nlibrary(stringr)\n\nhead(words)\n\n#> [1] \"a\"        \"able\"     \"about\"    \"absolute\" \"accept\"   \"account\"\n\nhead(sentences)\n\n#> [1] \"The birch canoe slid on the smooth planks.\" \n#> [2] \"Glue the sheet to the dark blue background.\"\n#> [3] \"It's easy to tell the depth of a well.\"     \n#> [4] \"These days a chicken leg is a rare dish.\"   \n#> [5] \"Rice is often served in round bowls.\"       \n#> [6] \"The juice of lemons makes fine punch.\"\n\nhead(fruit)\n\n#> [1] \"apple\"       \"apricot\"     \"avocado\"     \"banana\"      \"bell pepper\"\n#> [6] \"bilberry\""
  },
  {
    "objectID": "strings.html#basic-stringr-operations",
    "href": "strings.html#basic-stringr-operations",
    "title": "10  Strings",
    "section": "\n10.3 Basic \"stringr\" Operations",
    "text": "10.3 Basic \"stringr\" Operations\nMost stringr functions start with str_, which makes it particularly easy to remember. The following table contains the main stringr functions we’ll cover:\n\n\nFunction\nDescription\n\n\n\nstr_to_lower()\nconverts string to lower case\n\n\nstr_to_upper()\nconverts string to upper case\n\n\nstr_to_title()\nconverts string to title case\n\n\nstr_length()\nnumber of characters\n\n\nstr_sub()\nextracts substrings\n\n\nstr_locate()\nreturns indices of substrings\n\n\nstr_dup()\nduplicates characters\n\n\nstr_trim()\nremoves leading and trailing whitespace\n\n\nstr_pad()\npads a string\n\n\nstr_c()\nstring concatenation\n\n\nstr_split()\nsplit a string into a vector\n\n\nstr_sort()\nsort a string alphabetically\n\n\nstr_order()\nget the order of a sorted string\n\n\nstr_detect()\nmatch a string in another string\n\n\nstr_replace()\nreplace a string in another string\n\n\n\nThe common str_ prefix is particularly useful in RStudio, because typing str_ will trigger autocomplete, allowing you to see all stringr functions:\n\n\n10.3.1 Case conversion\nYou can convert whole strings to lower-case, upper-case, and title-case using some conveniently-named functions:\n\nx <- \"Want to hear a joke about paper? Never mind, it's tearable.\"\n\n\nstr_to_lower(x)\n\n#> [1] \"want to hear a joke about paper? never mind, it's tearable.\"\n\nstr_to_upper(x)\n\n#> [1] \"WANT TO HEAR A JOKE ABOUT PAPER? NEVER MIND, IT'S TEARABLE.\"\n\nstr_to_title(x)\n\n#> [1] \"Want To Hear A Joke About Paper? Never Mind, It's Tearable.\"\n\n\nSidenote: Notice that str_to_title() makes every first letter in each word upper case. This is slightly different from what you might expect, since most “titles” don’t make articles like “a” and “the” upper case. An alternative function that makes a more appropriate title case is the toTitleCase() function from the tools library:\n\nlibrary(tools)\ntoTitleCase(x)\n\n#> [1] \"Want to Hear a Joke About Paper? Never Mind, It's Tearable.\"\n\n\n\n10.3.2 Get the number of characters in a string\nIf you want to find how long a string is (i.e. how many characters it contains), the length() function won’t work:\n\nlength(\"hello world\")\n\n#> [1] 1\n\n\nThat’s be length() returns how many elements are in a vector (in the above case, there’s just one element). Instead, you should use str_length():\n\nstr_length(\"hello world\")\n\n#> [1] 11\n\n\nNote that the space character has a length:\n\nstr_length(\" \")\n\n#> [1] 1\n\n\nAlso note that the “empty” string (\"\") has no length:\n\nstr_length(\"\")\n\n#> [1] 0\n\n\n\n10.3.3 Access characters by their index\nYou can access individual character using str_sub(). It takes three arguments: a string (or character vector), a start position, and an end position. Either position can either be a positive integer, which counts from the left, or a negative integer which counts from the right. The positions are inclusive, and if longer than the string, will be silently truncated.\n\nx <- \"Apple\"\nstr_sub(x, 1, 3)\n\n#> [1] \"App\"\n\n# Negative numbers count backwards from the end\nstr_sub(x, -3, -1)\n\n#> [1] \"ple\"\n\n\nNote that str_sub() won’t fail if the string is too short: it will just return as much as possible:\n\nstr_sub(\"Apple\", 1, 10)\n\n#> [1] \"Apple\"\n\n\nYou can also use the assignment form of str_sub() to modify specific elements in strings:\n\nx <- 'abcdef'\nstr_sub(x, 1, 3) <- 'ABC'\nx\n\n#> [1] \"ABCdef\"\n\n\n\n10.3.4 Get the indices of substrings\nIf you want to know the start and end indices of a particular substring, use str_locate(). This is a helpful function to use in combination with str_sub() so you don’t have to count the characters to find a substring.\nFor example, let’s say I want to extract the substring \"Good\" from the following string:\n\nx <- 'thisIsGoodPractice'\n\nI could first use str_locate() to get the start and end indices:\n\nindices <- str_locate(x, 'Good')\nindices\n\n#>      start end\n#> [1,]     7  10\n\n\nNow that I have the start and end locations, I can use them within str_sub():\n\nstr_sub(x, indices[1], indices[2])\n\n#> [1] \"Good\"\n\n\n\n10.3.5 Repeat a string\nTo duplicate strings, use str_dup():\n\nstr_dup(\"hola\", 3)\n\n#> [1] \"holaholahola\"\n\n\nNote the difference with rep() (which returns a vector):\n\nrep(\"hola\", 3)\n\n#> [1] \"hola\" \"hola\" \"hola\"\n\n\n\n10.3.6 Removing “whitespace”\nstr_trim() removes leading and trailing whitespace:\n\nx <- \"         aStringWithSpace        \"\nx\n\n#> [1] \"         aStringWithSpace        \"\n\nstr_trim(x)\n\n#> [1] \"aStringWithSpace\"\n\n\nBy default, str_trim() removes whitespace on both sides, but you can specify a single side:\n\nstr_trim(x, side = \"left\") # Only trim left side\n\n#> [1] \"aStringWithSpace        \"\n\nstr_trim(x, side = \"right\") # Only trim right side\n\n#> [1] \"         aStringWithSpace\"\n\n\n\n10.3.7 Add whitespace (or other characters)\nstr_pad() pads a string to a fixed length by adding extra whitespace on the left, right, or both sides. Note that the width argument is the length of the final string (not the length of the added padding):\n\nx <- \"hello\"\nx\n\n#> [1] \"hello\"\n\nstr_pad(x, width = 10) # Inserts pad on left by default\n\n#> [1] \"     hello\"\n\nstr_pad(x, width = 10, side = \"both\") # Pad both sides\n\n#> [1] \"  hello   \"\n\n\nYou can pad with other characters by using the pad argument:\n\nstr_pad(x, 10, side=\"both\", pad='-')\n\n#> [1] \"--hello---\"\n\n\nAlso, str_pad() will never make a string shorter:\n\nstr_pad(x, 4)\n\n#> [1] \"hello\"\n\n\n\n10.3.8 Combine strings into one string\nTo combine two or more strings, use str_c():\n\nstr_c('x', 'y', 'z')\n\n#> [1] \"xyz\"\n\n\nUse the sep argument to control how they’re separated:\n\nstr_c('x', 'y', 'z', sep = \"-\")\n\n#> [1] \"x-y-z\"\n\n\nYou can also concatenate a vector of strings by adding the collapse argument to the str_c() function:\n\nstr_c(letters)\n\n#>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\"\n#> [19] \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nstr_c(letters, collapse = '')\n\n#> [1] \"abcdefghijklmnopqrstuvwxyz\"\n\nstr_c(letters, collapse = '-')\n\n#> [1] \"a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z\"\n\n\nObjects of length 0 are silently dropped. This is particularly useful in conjunction with if statements:\n\nprintGreeting <- function(name, timeOfDay, isBirthday) {\n    greeting <- str_c(\n        \"Good \", timeOfDay, \" \", name,\n            if (isBirthday) {\n                \", and HAPPY BIRTHDAY!\"\n            } else {\n                '.'\n            }\n        )\n    cat(greeting)\n}\n\n\nprintGreeting('John', 'morning', isBirthday = FALSE)\n\n#> Good morning John.\n\nprintGreeting('John', 'morning', isBirthday = TRUE)\n\n#> Good morning John, and HAPPY BIRTHDAY!\n\n\n\n10.3.9 Split a string into multiple strings\nUse str_split() to split a string up into pieces along a particular delimiter.\n\nstring <- 'This string has spaces-and-dashes'\n\n\nstr_split(string, \" \") # Split on the spaces\n\n#> [[1]]\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n\n\n\nstr_split(string, \"-\") # Split on the dashes\n\n#> [[1]]\n#> [1] \"This string has spaces\" \"and\"                   \n#> [3] \"dashes\"\n\n\nBy default, str_split() returns a list (another R data structure) of vectors. Each item in the list is a vector of strings. In the above cases, we gave str_split() a single string, so there is only one item in the returned list. In these cases, the easiest way to access the resulting vector of split strings is to use the double bracket [[]] operator to access the first list item:\n\nstr_split(string, \" \") # Returns a list of vectors\n\n#> [[1]]\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n\nstr_split(string, \" \")[[1]] # Returns the first vector in the list\n\n#> [1] \"This\"              \"string\"            \"has\"              \n#> [4] \"spaces-and-dashes\"\n\n\nIf you give str_split() a vector of strings, it will return a list of length equal to the number of elements in the vector:\n\nx <- c('babble', 'scrabblebabble')\nstr_split(x, 'bb') # Returns a list with two elements (each a vector)\n\n#> [[1]]\n#> [1] \"ba\" \"le\"\n#> \n#> [[2]]\n#> [1] \"scra\" \"leba\" \"le\"\n\n\nA particularly useful string split is to split on the empty string (\"\"), which breaks a string up into its individual characters:\n\nstr_split(string, \"\")[[1]]\n\n#>  [1] \"T\" \"h\" \"i\" \"s\" \" \" \"s\" \"t\" \"r\" \"i\" \"n\" \"g\" \" \" \"h\" \"a\" \"s\" \" \" \"s\" \"p\"\n#> [19] \"a\" \"c\" \"e\" \"s\" \"-\" \"a\" \"n\" \"d\" \"-\" \"d\" \"a\" \"s\" \"h\" \"e\" \"s\"\n\n\n\n10.3.10 Word extraction with word()\n\nThe word() function that another way to split up a longer string. It is designed to extract words from a sentence. You use word() by by passing it a string together with a start position of the first word to extract and an end position of the last word to extract. By default, the separator sep used between words is a single space. Here’s some examples:\n\nsentence <- c(\"Be the change you want to be\")\n\n\n# Extract first word\nword(sentence, 1)\n\n#> [1] \"Be\"\n\n# Extract second word\nword(sentence, 2)\n\n#> [1] \"the\"\n\n# Extract last word\nword(sentence, -1)\n\n#> [1] \"be\"\n\n# Extract all but the first word\nword(sentence, 2, -1)\n\n#> [1] \"the change you want to be\"\n\n\n\n10.3.11 Alphabetically sorting string vectors\nYou can sort a vector of strings alphabetically using str_sort() and str_order():\n\nx <- c('Y', 'M', 'C', 'A')\n\n\nstr_sort(x)\n\n#> [1] \"A\" \"C\" \"M\" \"Y\"\n\nstr_sort(x, decreasing = TRUE)\n\n#> [1] \"Y\" \"M\" \"C\" \"A\"\n\nstr_order(x)\n\n#> [1] 4 3 2 1\n\nx[str_order(x)]\n\n#> [1] \"A\" \"C\" \"M\" \"Y\"\n\n\n\n10.3.12 Detect if a pattern is in a string\nTo determine if a character vector matches a pattern, use str_detect(). It returns a logical vector the same length as the input:\n\ntenFruit <- fruit[1:10]\ntenFruit\n\n#>  [1] \"apple\"        \"apricot\"      \"avocado\"      \"banana\"      \n#>  [5] \"bell pepper\"  \"bilberry\"     \"blackberry\"   \"blackcurrant\"\n#>  [9] \"blood orange\" \"blueberry\"\n\nstr_detect(tenFruit, \"berry\")\n\n#>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nRemember that when you use a logical vector in a numeric context, FALSE becomes 0 and TRUE becomes 1. That makes sum() and mean() useful if you want to answer questions about matches across a vector:\n\n# How many fruit in tenFruit contain the string \"berry\"?\n# How many words in the stringr \"words\" vector contain the letter \"a\"?\nsum(str_detect(tenFruit, \"berry\"))\n\n#> [1] 3\n\n# What proportion contain the string \"berry\"?\nmean(str_detect(tenFruit, \"berry\"))\n\n#> [1] 0.3\n\n\nIf you want to count the number of times a particular string pattern appears, use str_count:\n\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"a\")\n\n#> [1] 1 3 1\n\n\n\n10.3.13 Anchors\nBy default, str_detect() will match any part of a string. But it’s often useful to anchor the matching condition so that it matches from the start or end of the string. You can use:\n\n\n^ to match the start of the string.\n\n$ to match the end of the string.\n\n\n# Which fruit start with \"a\"?\nstr_detect(tenFruit, \"^a\")\n\n#>  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Which fruit end with \"y\"?\nstr_detect(tenFruit, \"e$\")\n\n#>  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n\n\nTo remember which is which, try this mnemonic:\n\nIf you start with power (^), you’ll end up with money ($).\n\nTo force a match to a complete string, anchor it with both ^ and $:\n\nx <- c(\"apple pie\", \"apple\", \"apple cake\")\n\n\nstr_detect(x, \"apple\")\n\n#> [1] TRUE TRUE TRUE\n\nstr_detect(x, \"^apple$\")\n\n#> [1] FALSE  TRUE FALSE\n\n\nIn the second example above, 1 & 3 are FALSE because there’s a space after apple.\n\n10.3.14 Replacing matched pattern with another string\nstr_replace() and str_replace_all() allow you to replace matches with new strings. The simplest use is to replace a pattern with a fixed string:\n\nx <- c(\"apple\", \"pear\", \"banana\")\n\n\nstr_replace(x, \"a\", \"-\")\n\n#> [1] \"-pple\"  \"pe-r\"   \"b-nana\"\n\nstr_replace_all(x, \"a\", \"-\")\n\n#> [1] \"-pple\"  \"pe-r\"   \"b-n-n-\""
  },
  {
    "objectID": "strings.html#stringr-functions-work-on-vectors",
    "href": "strings.html#stringr-functions-work-on-vectors",
    "title": "10  Strings",
    "section": "\n10.4 stringr functions work on vectors",
    "text": "10.4 stringr functions work on vectors\nIn many of the above examples, we used a single string, but most stringr functions are designed to work on vectors of strings. For example, consider a vector of two “fruit”:\n\nx <- c(\"apples\", \"oranges\")\nx\n\n#> [1] \"apples\"  \"oranges\"\n\n\nGet the first 3 letters in each string in x:\n\nstr_sub(x, 1, 3)\n\n#> [1] \"app\" \"ora\"\n\n\nDuplicate each string in x twice:\n\nstr_dup(x, 2)\n\n#> [1] \"applesapples\"   \"orangesoranges\"\n\n\nConvert all strings in x to upper case:\n\nstr_to_upper(x)\n\n#> [1] \"APPLES\"  \"ORANGES\"\n\n\nReplace all \"a\" characters with a \"-\" character:\n\nstr_replace_all(x, \"a\", \"-\")\n\n#> [1] \"-pples\"  \"or-nges\""
  },
  {
    "objectID": "strings.html#tips",
    "href": "strings.html#tips",
    "title": "10  Strings",
    "section": "\n10.5 Tips",
    "text": "10.5 Tips\n\n10.5.1 Breaking a string into characters\nOften times you’ll want to break a string into it’s individual character components. To do that, use str_split() with the empty string \"\" as the delimiter:\n\nchars <- str_split(\"apples\", \"\")[[1]]\nchars\n\n#> [1] \"a\" \"p\" \"p\" \"l\" \"e\" \"s\"\n\n\n\n10.5.2 Breaking a sentence into words\nSimilarly, if you have a single string that contains words separated by spaces, splitting on \" \" will break it into words:\n\nx <- \"If you want to view paradise, simply look around and view it\"\nstr_split(x, \" \")[[1]]\n\n#>  [1] \"If\"        \"you\"       \"want\"      \"to\"        \"view\"      \"paradise,\"\n#>  [7] \"simply\"    \"look\"      \"around\"    \"and\"       \"view\"      \"it\"\n\n\n\n10.5.3 Comparing strings\nIf you want to compare whether two strings are the same, you must also consider their cases. For example:\n\na <- \"Apples\"\nb <- \"apples\"\na == b\n\n#> [1] FALSE\n\n\nThe above returns FALSE because the cases are different on the \"a\" characters. If you want to ignore case, then a common strategy is to first convert the strings to a common case before comparing. For example:\n\nstr_to_lower(a) == str_to_lower(b)\n\n#> [1] TRUE"
  },
  {
    "objectID": "strings.html#page-sources",
    "href": "strings.html#page-sources",
    "title": "10  Strings",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\n\nR for Data Science, by Garrett Grolemund & Hadley Wickham\n\nHandling Strings with R, by Gaston Sanchez\nIntroduction to stringr vignette"
  },
  {
    "objectID": "data-analysis.html#the-challenger-disaster",
    "href": "data-analysis.html#the-challenger-disaster",
    "title": "Data Analysis",
    "section": "The Challenger disaster",
    "text": "The Challenger disaster\nOn January 28, 1986 the space shuttle Challenger exploded. In his book titled “Visual Explanations”, Edward Tufte (1997) provides a detailed account of the background to the incident. In short, the temperature on the day of the launch was too low and resulted in failure of the O-rings in the rocket, which led to an explosion that destroyed the rocket and killed the 7-person crew, pictured below.\n [Image source]"
  },
  {
    "objectID": "data-analysis.html#the-data",
    "href": "data-analysis.html#the-data",
    "title": "Data Analysis",
    "section": "The data",
    "text": "The data\nThe R package DAAG has a dataset called orings which contains data on temperatures and O-ring damage during launches prior to the Challenger incident. Let’s load the DAAG library and preview the data:\n\nlibrary(DAAG)\n\nhead(orings)\n\n#>   Temperature Erosion Blowby Total\n#> 1          53       3      2     5\n#> 2          57       1      0     1\n#> 3          58       1      0     1\n#> 4          63       1      0     1\n#> 5          66       0      0     0\n#> 6          67       0      0     0\n\n\nWe can see that the dataset contains observations about the temperatures of launches and O-ring damage, but we don’t yet have information. One step forward towards information is to simply plot the data to see if there might be a relationship between temperature and O-ring damage:\n\nlibrary(ggplot2)\n\nchallengerPlot <- ggplot(\n        data = orings, \n        aes(x = Temperature, y = Total)\n    ) +\n    geom_point(size = 1.5) +\n    scale_x_continuous(\n        limits = c(25, 85), \n        breaks = seq(25, 85, 5)\n    ) +\n    scale_y_continuous(\n        limits = c(-0.15, 8), \n        breaks = seq(0, 8, 2)\n    ) +\n    labs(\n        x = 'Temperature (°F) of field joints at time of launch',\n        y = 'Total o-ring damage'\n    ) +\n    theme_bw() +\n    theme(panel.grid.minor = element_blank())\n\nchallengerPlot\n\n\n\n\n\n\n\nThe graph above shows O-ring damage on the y-axis and temperature on the x-axis. We can easily see that no prior launches below 66 degrees F were damage-free, and it appears that at lower temperatures (such as 55 degrees) the damage was even more severe.\nNow, what temperature was forecasted for the day of the Challenger launch? 26 to 29 degrees. Let’s add that context to our plot:\n\nannotation <- paste(\n    \"26°-29°:\", \"Range of forecasted temperatures\",\n    \"for Jan. 28, 1986 Challenger launch\", sep = \"\\n\"\n)\n\nchallengerPlot +\n    annotate(\n        \"rect\", \n        xmin = 26, xmax = 29,  ymin = -0.15, ymax = 0.15,\n        alpha = 0.6, fill = \"grey60\"\n    ) +\n    annotate(\n        \"text\", \n        x = 26, y = 1.4, label = annotation, \n        hjust = 0\n    )\n\n\n\n\n\n\n\nNow we have some information. The transformation of the raw data into a visualization makes it obvious that the temperature forecasted for the day of the Challenger launch should raise red flags. It falls far below the temperature range of prior launches, and those prior launches suggest that O-ring damage may be correlated with decreasing temperature.\nTo their credit, the engineers working on the Challenger were worried about the potential for O-ring failure. But the critical step in making the link to temperature was not thoroughly communicated. Instead, the raw data was presented in tabular form along with diagrams like the one below, which show how erosion in the primary O-ring interacted with the secondary O-ring:\n [Image source]\nWhile the above diagram contains a lot of data, the critical information about the relationship between launch temperature and O-ring damage is not obvious. In contrast, the scatterplot achieves this without putting much cognitive load on the viewer. Just about anyone can look at that plot and understand that the forecasted temperature on January 28, 1986 might be a risk for O-ring failure."
  },
  {
    "objectID": "data-analysis.html#references",
    "href": "data-analysis.html#references",
    "title": "Data Analysis",
    "section": "References",
    "text": "References\n\nThe Space shuttle Challenger explosion blog post, by Vikram Dayal\nRobison et al. (2002) Representation and Misrepresentation: Tufte and the Morton Thiokol Engineers on the Challenger, Science and Engineering Ethics, 8, 59-81.\nTufte, Edward R. (1997) “Visual Explanations: Images and Quantities, Evidence and Narrative”, Graphics Press, Cheshire, Connecticut."
  },
  {
    "objectID": "data-frames.html#the-data-frame",
    "href": "data-frames.html#the-data-frame",
    "title": "11  Data Frames",
    "section": "\n11.1 The data frame",
    "text": "11.1 The data frame\n\n11.1.1 What are data frames?\nData frames are the de facto data structure for most tabular data in R. A data frame can be created by hand, but most commonly they are generated by reading in a data file (typically a .csv file).\nA data frame is the representation of data in the format of a table where the columns are vectors of the same length. Because columns are vectors, each column must contain a single type of data (e.g., numeric, character, integer, logical). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector:\n\n\n11.1.2 The data.frame() function\nYou can create a data frame using the data.frame() function. Here is an example using of members of the Beatles band:\n\nbeatles <- data.frame(\n    firstName   = c(\"John\", \"Paul\", \"Ringo\", \"George\"),\n    lastName    = c(\"Lennon\", \"McCartney\", \"Starr\", \"Harrison\"),\n    instrument  = c(\"guitar\", \"bass\", \"drums\", \"guitar\"),\n    yearOfBirth = c(1940, 1942, 1940, 1943),\n    deceased    = c(TRUE, FALSE, FALSE, TRUE)\n)\nbeatles\n\n#>   firstName  lastName instrument yearOfBirth deceased\n#> 1      John    Lennon     guitar        1940     TRUE\n#> 2      Paul McCartney       bass        1942    FALSE\n#> 3     Ringo     Starr      drums        1940    FALSE\n#> 4    George  Harrison     guitar        1943     TRUE\n\n\nNotice how the data frame is created - you just hand the data.frame() function a bunch of vectors! This should hopefully help make it clear that a data frame is indeed a series of same-length vectors structured side-by-side.\n\n11.1.3 The tibble() function\nThe tibble is an improved version of the Base R data frame, and it comes from the dplyr library (which we’ll get into next lesson). If you haven’t already, go ahead and install and load the dplyr library now:\n\nlibrary(dplyr)\n\nA tibble works just like a data frame, but it has a few small features that make it a bit more useful - to the extent that from here on, we will be using tibbles as our default data frame structure. With this in mind, I’ll often use the term “data frame” to refer to both tibbles and data frames, since they serve the same purpose as a data structure.\nJust like with data frames, you can create a tibble using the tibble() function. Here’s the same example as before with the Beatles band:\n\nbeatles <- tibble(\n    firstName   = c(\"John\", \"Paul\", \"Ringo\", \"George\"),\n    lastName    = c(\"Lennon\", \"McCartney\", \"Starr\", \"Harrison\"),\n    instrument  = c(\"guitar\", \"bass\", \"drums\", \"guitar\"),\n    yearOfBirth = c(1940, 1942, 1940, 1943),\n    deceased    = c(TRUE, FALSE, FALSE, TRUE)\n)\nbeatles\n\n#> # A tibble: 4 × 5\n#>   firstName lastName  instrument yearOfBirth deceased\n#>   <chr>     <chr>     <chr>            <dbl> <lgl>   \n#> 1 John      Lennon    guitar            1940 TRUE    \n#> 2 Paul      McCartney bass              1942 FALSE   \n#> 3 Ringo     Starr     drums             1940 FALSE   \n#> 4 George    Harrison  guitar            1943 TRUE\n\n\nHere we can see a couple of the differences that make tibbles a bit more intuitive to use:\n\nIt’s easier to see what type of data each column is because tibbles display this in between the <> symbols under each column name.\nA tibble will only print the first few rows of data when you enter the object name. In contrast, data frames will try to print the entire data frame (which is super annoying when you have a data frame with millions of rows of data). Here, we only have 4 rows, so this difference is not apparent.\nColumns of class character are never converted into factors (don’t worry about this for now…just know that keeping strings as a character class generally makes life easier in R).\n\nNow that we have a data frame (tibble) defined, let’s see what we can do with it!\n\n11.1.4 Dimensions\nYou can get the dimensions of a data frame using the ncol(), nrow(), and dim() functions:\n\nnrow(beatles) # Returns the number of rows\n\n#> [1] 4\n\nncol(beatles) # Returns the number of columns\n\n#> [1] 5\n\ndim(beatles) # Returns a vector of the number rows and columns\n\n#> [1] 4 5\n\n\n\n11.1.5 Row and column names\nData frames must have column names, but row names are optional (by default, row names are just a sequence of numbers). The names() function returns the column names, or you can also be more specific and use the colnames() and rownames() functions:\n\nnames(beatles) # Returns a vector of the column names\n\n#> [1] \"firstName\"   \"lastName\"    \"instrument\"  \"yearOfBirth\" \"deceased\"\n\ncolnames(beatles) # Also returns a vector of the column names\n\n#> [1] \"firstName\"   \"lastName\"    \"instrument\"  \"yearOfBirth\" \"deceased\"\n\nrownames(beatles) # Returns a vector of the row names\n\n#> [1] \"1\" \"2\" \"3\" \"4\"\n\n\n\n11.1.6 Combining data frames\nYou can combine data frames using the bind_cols() and bind_rows() functions:\n\n# Combine columns\nnames <- tibble(\n    firstName = c(\"John\", \"Paul\", \"Ringo\", \"George\"),\n    lastName  = c(\"Lennon\", \"McCartney\", \"Starr\", \"Harrison\")\n)\ninstruments <- tibble(\n    instrument = c(\"guitar\", \"bass\", \"drums\", \"guitar\")\n)\nbind_cols(names, instruments)\n\n#> # A tibble: 4 × 3\n#>   firstName lastName  instrument\n#>   <chr>     <chr>     <chr>     \n#> 1 John      Lennon    guitar    \n#> 2 Paul      McCartney bass      \n#> 3 Ringo     Starr     drums     \n#> 4 George    Harrison  guitar\n\n\n\n# Combine rows\nmembers1 <- tibble(\n    firstName = c(\"John\", \"Paul\"),\n    lastName  = c(\"Lennon\", \"McCartney\")\n)\nmembers2 <- tibble(\n    firstName = c(\"Ringo\", \"George\"),\n    lastName  = c(\"Starr\", \"Harrison\")\n)\nbind_rows(members1, members2)\n\n#> # A tibble: 4 × 2\n#>   firstName lastName \n#>   <chr>     <chr>    \n#> 1 John      Lennon   \n#> 2 Paul      McCartney\n#> 3 Ringo     Starr    \n#> 4 George    Harrison\n\n\nNote that to combine rows, the column names must be the same. For example, if we change the second column name in members2 to \"LASTNAME\", you’ll get a data frame with three columns, two of which will have missing values:\n\ncolnames(members2) <- c(\"firstName\", \"LASTNAME\")\nbind_rows(members1, members2)\n\n#> # A tibble: 4 × 3\n#>   firstName lastName  LASTNAME\n#>   <chr>     <chr>     <chr>   \n#> 1 John      Lennon    <NA>    \n#> 2 Paul      McCartney <NA>    \n#> 3 Ringo     <NA>      Starr   \n#> 4 George    <NA>      Harrison"
  },
  {
    "objectID": "data-frames.html#accessing-elements",
    "href": "data-frames.html#accessing-elements",
    "title": "11  Data Frames",
    "section": "\n11.2 Accessing elements",
    "text": "11.2 Accessing elements\n\n11.2.1 Using the $ operator\nYou can extract columns from a data frame by name by using the $ operator plus the column name. For example, the instrument column can be accessed using beatles$instrument:\n\nbeatles$instrument\n\n#> [1] \"guitar\" \"bass\"   \"drums\"  \"guitar\"\n\n\n\n11.2.2 Using integer indices\nYou can access elements in a data frame using brackets [] and indices inside the brackets. The general form is:\nDF[ROWS, COLUMNS]\nTo index with integers, specify the row numbers and column numbers as vectors.\n\nbeatles[1, 2] # Select the element in row 1, column 2\n\n#> # A tibble: 1 × 1\n#>   lastName\n#>   <chr>   \n#> 1 Lennon\n\nbeatles[c(1, 2), c(2, 3)] # Select the elements in rows 1 & 2 and columns 2 & 3\n\n#> # A tibble: 2 × 2\n#>   lastName  instrument\n#>   <chr>     <chr>     \n#> 1 Lennon    guitar    \n#> 2 McCartney bass\n\nbeatles[1:2, 2:3] # Same thing, but using the \":\" operator\n\n#> # A tibble: 2 × 2\n#>   lastName  instrument\n#>   <chr>     <chr>     \n#> 1 Lennon    guitar    \n#> 2 McCartney bass\n\n\nIf you leave either the row or column index blank, it means “selects all”:\n\nbeatles[c(1, 2),] # Leaving the column index blank will select all columns\n\n#> # A tibble: 2 × 5\n#>   firstName lastName  instrument yearOfBirth deceased\n#>   <chr>     <chr>     <chr>            <dbl> <lgl>   \n#> 1 John      Lennon    guitar            1940 TRUE    \n#> 2 Paul      McCartney bass              1942 FALSE\n\nbeatles[,c(1, 2)] # Leaving the row index blank will select all rows\n\n#> # A tibble: 4 × 2\n#>   firstName lastName \n#>   <chr>     <chr>    \n#> 1 John      Lennon   \n#> 2 Paul      McCartney\n#> 3 Ringo     Starr    \n#> 4 George    Harrison\n\n\nYou can also use negative integers to specify rows or columns to be excluded:\n\nbeatles[-1, ] # Select all rows and except the first\n\n#> # A tibble: 3 × 5\n#>   firstName lastName  instrument yearOfBirth deceased\n#>   <chr>     <chr>     <chr>            <dbl> <lgl>   \n#> 1 Paul      McCartney bass              1942 FALSE   \n#> 2 Ringo     Starr     drums             1940 FALSE   \n#> 3 George    Harrison  guitar            1943 TRUE\n\n\n\n11.2.3 Using character indices\nYou can use the column names to select elements in a data frame. If you do not include a , to designate which rows to select, R will return all the rows for the selected columns:\n\nbeatles[c('firstName', 'lastName')] # Select all rows for the \"firstName\" and \"lastName\" columns\n\n#> # A tibble: 4 × 2\n#>   firstName lastName \n#>   <chr>     <chr>    \n#> 1 John      Lennon   \n#> 2 Paul      McCartney\n#> 3 Ringo     Starr    \n#> 4 George    Harrison\n\nbeatles[1:2, c('firstName', 'lastName')] # Select just the first two rows for the \"firstName\" and \"lastName\" columns\n\n#> # A tibble: 2 × 2\n#>   firstName lastName \n#>   <chr>     <chr>    \n#> 1 John      Lennon   \n#> 2 Paul      McCartney\n\n\n\n11.2.4 Using logical indices\nWhen using a logical vector for indexing, the position where the logical vector is TRUE is returned. This is helpful for filtering data frame rows based on conditions. For example, if you wanted to filter out the rows for which Beatles members were still alive, you could first create a logical vector using the deceased column:\n\nbeatles$deceased == FALSE\n\n#> [1] FALSE  TRUE  TRUE FALSE\n\n\nThen, you could insert this logical vector in the row position of the [] brackets to filter only the rows that are TRUE:\n\nbeatles[beatles$deceased == FALSE,]\n\n#> # A tibble: 2 × 5\n#>   firstName lastName  instrument yearOfBirth deceased\n#>   <chr>     <chr>     <chr>            <dbl> <lgl>   \n#> 1 Paul      McCartney bass              1942 FALSE   \n#> 2 Ringo     Starr     drums             1940 FALSE\n\n\n\n11.2.5 Modifying data frames\nYou can use any of the above methods for accessing elements in a data frame to also modify those elements using the assignment operator (<-). In addition to using brackets to modify specific elements, you can use the $ operator to create new columns in a data frame.\nFor example, let’s create the variable age by subtracting the yearOfBirth variable from the current year:\n\nbeatles$age <- 2019 - beatles$yearOfBirth\nbeatles\n\n#> # A tibble: 4 × 6\n#>   firstName lastName  instrument yearOfBirth deceased   age\n#>   <chr>     <chr>     <chr>            <dbl> <lgl>    <dbl>\n#> 1 John      Lennon    guitar            1940 TRUE        79\n#> 2 Paul      McCartney bass              1942 FALSE       77\n#> 3 Ringo     Starr     drums             1940 FALSE       79\n#> 4 George    Harrison  guitar            1943 TRUE        76\n\n\nYou can also make a new column of all the same value by just providing one value:\n\nbeatles$hometown <- 'Liverpool'\nbeatles\n\n#> # A tibble: 4 × 7\n#>   firstName lastName  instrument yearOfBirth deceased   age hometown \n#>   <chr>     <chr>     <chr>            <dbl> <lgl>    <dbl> <chr>    \n#> 1 John      Lennon    guitar            1940 TRUE        79 Liverpool\n#> 2 Paul      McCartney bass              1942 FALSE       77 Liverpool\n#> 3 Ringo     Starr     drums             1940 FALSE       79 Liverpool\n#> 4 George    Harrison  guitar            1943 TRUE        76 Liverpool"
  },
  {
    "objectID": "data-frames.html#dealing-with-actual-data",
    "href": "data-frames.html#dealing-with-actual-data",
    "title": "11  Data Frames",
    "section": "\n11.3 Dealing with actual data",
    "text": "11.3 Dealing with actual data\nNow that we know what a data frame is, let’s start working with actual data! We are going to use the msleep dataset, which contains data on sleep times and weights of different mammals. The data are taken from V. M. Savage and G. B. West. “A quantitative, theoretical framework for understanding mammalian sleep.” Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007..\nThe dataset is stored as a comma separated value (CSV) file. Each row holds information for a single animal, and the columns represent:\n\n\nColumn Name\nDescription\n\n\n\nname\nCommon name\n\n\ngenus\nThe taxonomic genus of animal\n\n\nvore\nCarnivore, omnivore or herbivore?\n\n\norder\nThe taxonomic order of animal\n\n\nconservation\nThe conservation status of the animal\n\n\nsleep_total\nTotal amount of sleep, in hours\n\n\nsleep_rem\nREM sleep, in hours\n\n\nsleep_cycle\nLength of sleep cycle, in hours\n\n\nawake\nAmount of time spent awake, in hours\n\n\nbrainwt\nBrain weight in kilograms\n\n\nbodywt\nBody weight in kilograms\n\n\n\n\n11.3.1 R Setup\nBefore we dig into the data, let’s prepare our analysis environment by following these steps:\n\nCreate a new R Project called “data_analysis_tutorial” and save the folder somewhere on your computer (see the “RStudio projects” section from lesson 1 if you’re not sure what this is). This will create a folder called “data_analysis_tutorial” and also a data_analysis_tutorial.RProj file inside that folder.\nCreate a new .R file (File > New File > R Script), and save it as data_frames.R inside your “data_analysis_tutorial” folder. From here on, we’ll type all code for this lesson inside this data_frames.R file.\nCreate another folder in your R Project folder called “data” - we’ll put data in this folder real soon.\n\nNow that you’ve gotten your setup organized, go ahead and open the data_analysis_tutorial.RProj file to open RStudio, then click on the data_frames.R file. We’ll write code in this file.\nThere are generally two ways to load external data.\n\n11.3.2 Method 1: Loading data from a package\nMany R packages come with pre-loaded datasets. For example, the ggplot2 library (which we’ll use soon to make plots in R) comes with the msleep dataset already loaded. To see this, install ggplot2 and load the library:\n\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)\nhead(msleep) # Preview just the first 6 rows of the data frame\n\n\n\n#> # A tibble: 6 × 11\n#>   name       genus vore  order conse…¹ sleep…² sleep…³ sleep…⁴ awake  brainwt\n#>   <chr>      <chr> <chr> <chr> <chr>     <dbl>   <dbl>   <dbl> <dbl>    <dbl>\n#> 1 Cheetah    Acin… carni Carn… lc         12.1    NA    NA      11.9 NA      \n#> 2 Owl monkey Aotus omni  Prim… <NA>       17       1.8  NA       7    0.0155 \n#> 3 Mountain … Aplo… herbi Rode… nt         14.4     2.4  NA       9.6 NA      \n#> 4 Greater s… Blar… omni  Sori… lc         14.9     2.3   0.133   9.1  0.00029\n#> 5 Cow        Bos   herbi Arti… domest…     4       0.7   0.667  20    0.423  \n#> 6 Three-toe… Brad… herbi Pilo… <NA>       14.4     2.2   0.767   9.6 NA      \n#> # … with 1 more variable: bodywt <dbl>, and abbreviated variable names\n#> #   ¹​conservation, ²​sleep_total, ³​sleep_rem, ⁴​sleep_cycle\n\n\nIf you want to see all of the different datasets that any particular package contains, you can call the data() function after loading a library. For example, here are all the dataset that are contained in the ggplot2 library:\n\ndata(package = \"ggplot2\")\n\nData sets in package 'ggplot2':\n\ndiamonds                Prices of 50,000 round cut diamonds\neconomics               US economic time series\neconomics_long          US economic time series\nfaithfuld               2d density estimate of Old Faithful data\nluv_colours             'colors()' in Luv space\nmidwest                 Midwest demographics\nmpg                     Fuel economy data from 1999 and 2008 for 38\n                        popular models of car\nmsleep                  An updated and expanded version of the mammals\n                        sleep dataset\npresidential            Terms of 11 presidents from Eisenhower to Obama\nseals                   Vector field of seal movements\ntxhousing               Housing sales in TX\n\n11.3.3 Method 2: Importing data\nWhat do you do when a dataset isn’t available from a package? Well, you can “read” the data into R from an external file. One of the most common format for storing tabular data (i.e. data that is stored as rows and columns) is the comma separated value (CSV) file.\nTo try this out yourself, download this msleep.csv file (click the link, then go to “File -> Save” to save it) and put the file in your “data” folder that you created inside your “data_analysis_tutorial” folder.\nNote:\n\n\nDO NOT double-click the msleep.csv file!\n\nDO NOT open it in Excel!\n\nWe are going to read this data into R, so fight the temptation to open it in any other program!\n\n11.3.3.1 Steps to importing external data files\n\n\nCreate a path to the data\n::: {.cell layout-align=“center”}\nlibrary(here)\n::: {.cell-output .cell-output-stderr} #> here() starts at /Users/runner/work/p4a/p4a :::\npathToData <- here('data', 'data.csv')\n:::\n\n\nImport the data\n::: {.cell layout-align=“center”}\nlibrary(readr)\ndf <- read_csv(pathToData)\n:::\n\n\nLet’s break these steps down. First, I strongly recommend that you create the path to the data using the here package. The here() function builds the path to your current working directory (this is where your data_analysis_tutorial.Rproj file lives!). For example, if I put my “data analysis tutorial” folder on my computer’s desktop and opened up the data_analysis_tutorial.Rproj file, this is what the here() function would produce:\n\nhere()\n\n\"/Users/jhelvy/Desktop/data_analysis_tutorial\"\nThe specific path will look different depending on where you put your project, and that’s what is so powerful! Now I can run this code on any computer and I’ll get a dynamically-generated path!\nThe arguments I give to the here() function are the sequence of folders and files that are inside my working directory. Since I put the msleep.csv file inside a folder called “data”, I can get the path to that file like this:\n\npathToData <- here('data', 'msleep.csv')\npathToData\n\n\"/Users/jhelvy/Desktop/data_analysis_tutorial/data/msleep.csv\"\nNote: Avoid hard-coding file paths (e.g. 'data/msleep.csv')!\nThis can break on different computers 💩💩💩\nFile paths create so many issues that the brilliant Allison Horst even made this lovely art to remind us about the joy of the here package 😄\n\nOnce you’ve got your file path, you are now ready to load the data! The Base R function for reading in a csv file is called read.csv(), but it has some quirky aspects in how it formats the data (in particular, character variables). So instead we are going to use an improved function, read_csv(), from the readr package.\nFirst, install the readr package if you haven’t already:\n\ninstall.packages(\"readr\")\n\nNow load the data:\n\nlibrary(readr)\nmsleep <- read_csv(here('data', 'msleep.csv'))\n\n#> Rows: 83 Columns: 11\n#> ── Column specification ─────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr (5): name, genus, vore, order, conservation\n#> dbl (6): sleep_total, sleep_rem, sleep_cycle, awake, brainwt, bodywt\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nR tells us that we’ve successfully read in some data and a quick summary of the data type for each column in the dataset.\n\n11.3.4 Previewing the data\nYou can view the entire dataset in a tabular format (similar to how Excel looks) by using the View() function, which opens up another tab to view the data. Note that you cannot modify the data this way - you can just look at it:\n\nView(msleep)\n\nIn addition to viewing the whole dataset with View(), you can quickly view summaries of the data frame with a few convenient functions. For example, you can look at the first 6 rows by using the head() function:\n\nhead(msleep)\n\n#> # A tibble: 6 × 11\n#>   name       genus vore  order conse…¹ sleep…² sleep…³ sleep…⁴ awake  brainwt\n#>   <chr>      <chr> <chr> <chr> <chr>     <dbl>   <dbl>   <dbl> <dbl>    <dbl>\n#> 1 Cheetah    Acin… carni Carn… lc         12.1    NA    NA      11.9 NA      \n#> 2 Owl monkey Aotus omni  Prim… <NA>       17       1.8  NA       7    0.0155 \n#> 3 Mountain … Aplo… herbi Rode… nt         14.4     2.4  NA       9.6 NA      \n#> 4 Greater s… Blar… omni  Sori… lc         14.9     2.3   0.133   9.1  0.00029\n#> 5 Cow        Bos   herbi Arti… domest…     4       0.7   0.667  20    0.423  \n#> 6 Three-toe… Brad… herbi Pilo… <NA>       14.4     2.2   0.767   9.6 NA      \n#> # … with 1 more variable: bodywt <dbl>, and abbreviated variable names\n#> #   ¹​conservation, ²​sleep_total, ³​sleep_rem, ⁴​sleep_cycle\n\n\nSimilarly, you can view the last 6 rows by using the tail() function:\n\ntail(msleep)\n\n#> # A tibble: 6 × 11\n#>   name        genus vore  order conse…¹ sleep…² sleep…³ sleep…⁴ awake brainwt\n#>   <chr>       <chr> <chr> <chr> <chr>     <dbl>   <dbl>   <dbl> <dbl>   <dbl>\n#> 1 Tenrec      Tenr… omni  Afro… <NA>       15.6     2.3  NA       8.4  0.0026\n#> 2 Tree shrew  Tupa… omni  Scan… <NA>        8.9     2.6   0.233  15.1  0.0025\n#> 3 Bottle-nos… Turs… carni Ceta… <NA>        5.2    NA    NA      18.8 NA     \n#> 4 Genet       Gene… carni Carn… <NA>        6.3     1.3  NA      17.7  0.0175\n#> 5 Arctic fox  Vulp… carni Carn… <NA>       12.5    NA    NA      11.5  0.0445\n#> 6 Red fox     Vulp… carni Carn… <NA>        9.8     2.4   0.35   14.2  0.0504\n#> # … with 1 more variable: bodywt <dbl>, and abbreviated variable names\n#> #   ¹​conservation, ²​sleep_total, ³​sleep_rem, ⁴​sleep_cycle\n\n\nYou can also view an overview summary of each column and it’s data types by using the str() or glimpse() functions (these both do the same thing, but I prefer the output of glimpse()):\n\nglimpse(msleep)\n\n#> Rows: 83\n#> Columns: 11\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater s…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"c…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"…\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.…\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0…\n\n\nFinally, you can view summary statistics for each column using the summary() function:\n\nsummary(msleep)\n\n#>      name              genus               vore              order          \n#>  Length:83          Length:83          Length:83          Length:83         \n#>  Class :character   Class :character   Class :character   Class :character  \n#>  Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>                                                                             \n#>  conservation        sleep_total      sleep_rem      sleep_cycle    \n#>  Length:83          Min.   : 1.90   Min.   :0.100   Min.   :0.1167  \n#>  Class :character   1st Qu.: 7.85   1st Qu.:0.900   1st Qu.:0.1833  \n#>  Mode  :character   Median :10.10   Median :1.500   Median :0.3333  \n#>                     Mean   :10.43   Mean   :1.875   Mean   :0.4396  \n#>                     3rd Qu.:13.75   3rd Qu.:2.400   3rd Qu.:0.5792  \n#>                     Max.   :19.90   Max.   :6.600   Max.   :1.5000  \n#>                                     NA's   :22      NA's   :51      \n#>      awake          brainwt            bodywt        \n#>  Min.   : 4.10   Min.   :0.00014   Min.   :   0.005  \n#>  1st Qu.:10.25   1st Qu.:0.00290   1st Qu.:   0.174  \n#>  Median :13.90   Median :0.01240   Median :   1.670  \n#>  Mean   :13.57   Mean   :0.28158   Mean   : 166.136  \n#>  3rd Qu.:16.15   3rd Qu.:0.12550   3rd Qu.:  41.750  \n#>  Max.   :22.10   Max.   :5.71200   Max.   :6654.000  \n#>                  NA's   :27\n\n\nIn summary, here is a non-exhaustive list of functions to get a sense of the content/structure of a data frame:\n\nSize:\n\n\ndim(df) - returns a vector with the number of rows in the first element, and the number of columns as the second element (the dimensions of the object).\n\nnrow(df) - returns the number of rows.\n\nncol(df) - returns the number of columns.\n\n\nContent:\n\n\nhead(df) - shows the first 6 rows.\n\ntail(df) - shows the last 6 rows.\n\n\nNames:\n\n\nnames(df) - returns the column names (synonym of colnames() for data.frame objects).\n\nrownames(df) - returns the row names.\n\n\nSummary:\n\n\nglimpse(df) or str(df) - structure of the object and information about the class, length and content of each column.\n\nsummary(df) - summary statistics for each column.\n\n\n\nNote: most of these functions are “generic”, they can be used on other types of objects besides data.frame."
  },
  {
    "objectID": "data-frames.html#now-what",
    "href": "data-frames.html#now-what",
    "title": "11  Data Frames",
    "section": "\n11.4 Now what?",
    "text": "11.4 Now what?\nNow that you’ve got some data into R and are up to speed with what a data frame / tibble is, you may be asking, “so what now?” Well, over the next two lessons we will learn more about how to manipulate data frames and explore the underlying information with visualizations.\nBut just to give you an idea of where we’re going, here are a few pieces of information from the msleep dataset:\n\nIt appears that mammalian brain and body weight are logarithmically correlated - cool!\n\n\nlibrary(ggplot2)\nggplot(msleep, aes(x=brainwt, y=bodywt)) +\n    geom_point(alpha=0.6) +\n    stat_smooth(method='lm', col='red', se=F, size=0.7) +\n    scale_x_log10() +\n    scale_y_log10() +\n    labs(x='log(brain weight) in g', y='log(body weight) in kg') +\n    theme_minimal()\n\n\n\n\n\n\n\n\nIt appears there may also be a negative, logarithmic relationship (albeit weaker) between the size of mammalian brains and how much they sleep - cool!\n\n\nggplot(msleep, aes(x=brainwt, y=sleep_total)) +\n    geom_point(alpha=0.6) +\n    scale_x_log10() +\n    scale_y_log10() +\n    stat_smooth(method='lm', col='red', se=F, size=0.7) +\n    labs(x='log(brain weight) in g', y='log(total sleep time) in hours') +\n    theme_minimal()\n\n\n\n\n\n\n\n\nWow, there’s a lot of variation in how much different mammals sleep - cool!\n\n\nggplot(msleep, aes(x=sleep_total)) +\n    geom_histogram() +\n    labs(x     = 'Total sleep time in hours',\n         title = 'Histogram of total sleep time') +\n    theme_minimal()"
  },
  {
    "objectID": "data-frames.html#page-sources",
    "href": "data-frames.html#page-sources",
    "title": "11  Data Frames",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\n\nData Analysis and Visualization in R for Ecologists, by François Michonneau & Auriel Fournier. Zenodo: http://doi.org/10.5281/zenodo.3264888"
  },
  {
    "objectID": "data-wrangling.html#r-setup",
    "href": "data-wrangling.html#r-setup",
    "title": "12  Data Wrangling",
    "section": "\n12.1 R Setup",
    "text": "12.1 R Setup\nBefore we get started, let’s set up our analysis environment:\n\nOpen up your “data-analysis-tutorial” R Project that you created in the last lesson - if you didn’t do this, go back and do it now.\nCreate a new .R file (File > New File > R Script), and save it as “data_wrangling.R” inside your “data-analysis-tutorial” R Project folder.\nUse the download.file() function to download the wildlife_impacts.csv dataset, and save it in the data folder in your R Project:\n\n\ndownload.file(\n    url = \"https://github.com/emse6574-gwu/2019-Fall/raw/gh-pages/data/wildlife_impacts.csv\",\n    destfile = file.path('data', 'wildlife_impacts.csv')\n)\n\nFor this lesson, we are going to use the FAA Wildlife Strike Database, which contains records of reported wildlife strikes with aircraft since 1990. Since aircraft-wildlife impacts are voluntarily reported, the database only contains information from airlines, airports, pilots, and other sources and does not represent all strikes. Each row in the dataset holds information for a single strike event with the following columns:\n\n\n\n\n\n\n\nVariable\nClass\nDescription\n\n\n\nincident_date\ndate\nDate of incident\n\n\nstate\ncharacter\nState\n\n\nairport_id\ncharacter\nICAO Airport ID\n\n\nairport\ncharacter\nAirport Name\n\n\noperator\ncharacter\nOperator/Airline\n\n\natype\ncharacter\nAirline type\n\n\ntype_eng\ncharacter\nEngine type\n\n\nspecies_id\ncharacter\nSpecies ID\n\n\nspecies\ncharacter\nSpecies\n\n\ndamage\ncharacter\nDamage: N None M Minor, M Uncertain, S Substantial, D Destroyed\n\n\nnum_engs\ncharacter\nNumber of engines\n\n\nincident_month\ndouble\nIncident month\n\n\nincident_year\ndouble\nIncident year\n\n\ntime_of_day\ncharacter\nIncident Time of day\n\n\ntime\ndouble\nIncident time\n\n\nheight\ndouble\nPlane height at impact (feet)\n\n\nspeed\ndouble\nPlane speed at impact (knots)\n\n\nphase_of_flt\ncharacter\nPhase of flight at impact\n\n\nsky\ncharacter\nSky condition\n\n\nprecip\ncharacter\nPrecipitation\n\n\ncost_repairs_infl_adj\ndouble\nCost of repairs adjusted for inflation\n\n\n\nLet’s load our libraries and read in the data:\n\nlibrary(readr)\nlibrary(dplyr)\ndf <- read_csv(file.path('data', 'wildlife_impacts.csv'))\n\nJust like in the last lesson, a good starting point when working with a new dataset is to view some quick summaries. Here’s another summary function (glimpse()) that is similar to str():\n\nglimpse(df)\n\n#> Rows: 56,978\n#> Columns: 21\n#> $ incident_date         <dttm> 2018-12-31, 2018-12-29, 2018-12-29, 2018-12-…\n#> $ state                 <chr> \"FL\", \"IN\", \"N/A\", \"N/A\", \"N/A\", \"FL\", \"FL\", …\n#> $ airport_id            <chr> \"KMIA\", \"KIND\", \"ZZZZ\", \"ZZZZ\", \"ZZZZ\", \"KMIA…\n#> $ airport               <chr> \"MIAMI INTL\", \"INDIANAPOLIS INTL ARPT\", \"UNKN…\n#> $ operator              <chr> \"AMERICAN AIRLINES\", \"AMERICAN AIRLINES\", \"AM…\n#> $ atype                 <chr> \"B-737-800\", \"B-737-800\", \"UNKNOWN\", \"B-737-9…\n#> $ type_eng              <chr> \"D\", \"D\", NA, \"D\", \"D\", \"D\", \"D\", \"D\", \"D\", \"…\n#> $ species_id            <chr> \"UNKBL\", \"R\", \"R2004\", \"N5205\", \"J2139\", \"UNK…\n#> $ species               <chr> \"Unknown bird - large\", \"Owls\", \"Short-eared …\n#> $ damage                <chr> \"M?\", \"N\", NA, \"M?\", \"M?\", \"N\", \"N\", \"N\", \"N\"…\n#> $ num_engs              <dbl> 2, 2, NA, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,…\n#> $ incident_month        <dbl> 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 1…\n#> $ incident_year         <dbl> 2018, 2018, 2018, 2018, 2018, 2018, 2018, 201…\n#> $ time_of_day           <chr> \"Day\", \"Night\", NA, NA, NA, \"Day\", \"Night\", N…\n#> $ time                  <dbl> 1207, 2355, NA, NA, NA, 955, 948, NA, NA, 132…\n#> $ height                <dbl> 700, 0, NA, NA, NA, NA, 600, NA, NA, 0, NA, 0…\n#> $ speed                 <dbl> 200, NA, NA, NA, NA, NA, 145, NA, NA, 130, NA…\n#> $ phase_of_flt          <chr> \"Climb\", \"Landing Roll\", NA, NA, NA, \"Approac…\n#> $ sky                   <chr> \"Some Cloud\", NA, NA, NA, NA, NA, \"Some Cloud…\n#> $ precip                <chr> \"None\", NA, NA, NA, NA, NA, \"None\", NA, NA, \"…\n#> $ cost_repairs_infl_adj <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\n\nWow, there have been 56,978 reported wildlife strikes over the 29 period from 1990 to 2019! On a daily average that comes out to:\n\nnrow(df) / (2019 - 1990) / 365\n\n#> [1] 5.3829\n\n\n…over 5 strikes per day!"
  },
  {
    "objectID": "data-wrangling.html#data-wrangling-with-dplyr",
    "href": "data-wrangling.html#data-wrangling-with-dplyr",
    "title": "12  Data Wrangling",
    "section": "\n12.2 Data wrangling with dplyr\n",
    "text": "12.2 Data wrangling with dplyr\n\n[Art by Allison Horst]\n“Data Wrangling” refers to the art of getting your data into R in a useful form for visualization and modeling. Wrangling is the first step in the general data science process:\n\n\n\n\n12.2.1 What is dplyr\n\nAs we saw in the last section, we can use brackets ([]) to access elements of a data frame. While this is handy, it can be cumbersome and difficult to read, especially for complicated operations.\nEnter dplyr\nThe dplyr package was designed to make tabular data wrangling easier to perform and read. It pairs nicely with other libraries, such as ggplot2 for visualizing data (which we’ll cover next week). Together, dplyr, ggplot2, and a handful of other packages make up what is known as the “Tidyverse” - an opinionated collection of R packages designed for data science. You can load all of the tidyverse packages at once using the library(tidyverse) command, but for now we’re just going to install and use each package one at a time - starting with dplyr:\n\ninstall.packages(\"dplyr\")\n\nIn this lesson, we are going to learn some of the most common dplyr functions:\n\n\nselect(): subset columns\n\nfilter(): subset rows on conditions\n\nmutate(): create new columns by using information from other columns\n\narrange(): sort results\n\ngroup_by(): group data to perform grouped operations\n\nsummarize(): create summary statistics (usually on grouped data)\n\ncount(): count discrete rows\n\n12.2.2 Select columns with select()\n\n\nTo select specific columns, use select(). The first argument to this function is the data frame (df), and the subsequent arguments are the columns to keep:\n\n# Select only a few columns\nselect(df, state, damage, time_of_day)\n\n#> # A tibble: 56,978 × 3\n#>   state damage time_of_day\n#>   <chr> <chr>  <chr>      \n#> 1 FL    M?     Day        \n#> 2 IN    N      Night      \n#> 3 N/A   <NA>   <NA>       \n#> 4 N/A   M?     <NA>       \n#> 5 N/A   M?     <NA>       \n#> 6 FL    N      Day        \n#> # … with 56,972 more rows\n\n\nTo select all columns except certain ones, put a - sign in front of the variable to exclude it:\n\nselect(df, -state, -damage, -time_of_day)\n\n#> # A tibble: 56,978 × 18\n#>   incident_date       airport…¹ airport opera…² atype type_…³ speci…⁴ species\n#>   <dttm>              <chr>     <chr>   <chr>   <chr> <chr>   <chr>   <chr>  \n#> 1 2018-12-31 00:00:00 KMIA      MIAMI … AMERIC… B-73… D       UNKBL   Unknow…\n#> 2 2018-12-29 00:00:00 KIND      INDIAN… AMERIC… B-73… D       R       Owls   \n#> 3 2018-12-29 00:00:00 ZZZZ      UNKNOWN AMERIC… UNKN… <NA>    R2004   Short-…\n#> 4 2018-12-27 00:00:00 ZZZZ      UNKNOWN AMERIC… B-73… D       N5205   Southe…\n#> 5 2018-12-27 00:00:00 ZZZZ      UNKNOWN AMERIC… B-73… D       J2139   Lesser…\n#> 6 2018-12-27 00:00:00 KMIA      MIAMI … AMERIC… A-319 D       UNKB    Unknow…\n#> # … with 56,972 more rows, 10 more variables: num_engs <dbl>,\n#> #   incident_month <dbl>, incident_year <dbl>, time <dbl>, height <dbl>,\n#> #   speed <dbl>, phase_of_flt <chr>, sky <chr>, precip <chr>,\n#> #   cost_repairs_infl_adj <dbl>, and abbreviated variable names ¹​airport_id,\n#> #   ²​operator, ³​type_eng, ⁴​species_id\n\n\nSome additional options to select columns based on a specific criteria include:\n\n\nends_with() = Select columns that end with a character string\n\ncontains() = Select columns that contain a character string\n\nmatches() = Select columns that match a regular expression\n\none_of() = Select column names that are from a group of names\n\n12.2.3 Select rows with filter()\n\n\nFilter the rows for wildlife impacts that occurred in DC:\n\nfilter(df, state == 'DC')\n\n#> # A tibble: 1,228 × 21\n#>   incident_date       state airport_id airport  opera…¹ atype type_…² speci…³\n#>   <dttm>              <chr> <chr>      <chr>    <chr>   <chr> <chr>   <chr>  \n#> 1 2018-10-23 00:00:00 DC    KDCA       RONALD … AMERIC… B-73… D       UNKBS  \n#> 2 2018-10-17 00:00:00 DC    KDCA       RONALD … AMERIC… B-73… D       UNKBS  \n#> 3 2018-10-16 00:00:00 DC    KDCA       RONALD … AMERIC… B-73… D       YL001  \n#> 4 2018-10-12 00:00:00 DC    KDCA       RONALD … AMERIC… B-73… D       UNKBS  \n#> 5 2018-09-04 00:00:00 DC    KDCA       RONALD … AMERIC… A-319 D       UNKB   \n#> 6 2018-09-01 00:00:00 DC    KDCA       RONALD … AMERIC… A-321 D       UNKBS  \n#> # … with 1,222 more rows, 13 more variables: species <chr>, damage <chr>,\n#> #   num_engs <dbl>, incident_month <dbl>, incident_year <dbl>,\n#> #   time_of_day <chr>, time <dbl>, height <dbl>, speed <dbl>,\n#> #   phase_of_flt <chr>, sky <chr>, precip <chr>,\n#> #   cost_repairs_infl_adj <dbl>, and abbreviated variable names ¹​operator,\n#> #   ²​type_eng, ³​species_id\n\n\nFilter the rows for wildlife impacts that cost more than $1 million in damages:\n\nfilter(df, cost_repairs_infl_adj > 10^6)\n\n#> # A tibble: 41 × 21\n#>   incident_date       state airport_id airport  opera…¹ atype type_…² speci…³\n#>   <dttm>              <chr> <chr>      <chr>    <chr>   <chr> <chr>   <chr>  \n#> 1 2015-05-26 00:00:00 N/A   SVMI       SIMON B… AMERIC… B-73… D       K1     \n#> 2 2015-04-25 00:00:00 FL    KJAX       JACKSON… AMERIC… A-319 D       J2204  \n#> 3 2015-04-02 00:00:00 MA    KBOS       GENERAL… AMERIC… B-73… D       UNKBL  \n#> 4 2001-04-02 00:00:00 N/A   LFPG       CHARLES… AMERIC… B-76… D       J2131  \n#> 5 2015-10-08 00:00:00 WA    KSEA       SEATTLE… DELTA … A-330 D       K3302  \n#> 6 2015-09-23 00:00:00 UT    KSLC       SALT LA… DELTA … B-73… D       I6107  \n#> # … with 35 more rows, 13 more variables: species <chr>, damage <chr>,\n#> #   num_engs <dbl>, incident_month <dbl>, incident_year <dbl>,\n#> #   time_of_day <chr>, time <dbl>, height <dbl>, speed <dbl>,\n#> #   phase_of_flt <chr>, sky <chr>, precip <chr>,\n#> #   cost_repairs_infl_adj <dbl>, and abbreviated variable names ¹​operator,\n#> #   ²​type_eng, ³​species_id\n\n\n\n12.2.4 Sequence operations with pipes (%>%)\n (logo is a reference to The Treachery of Images)\nWhat if you want to select and filter at the same time? Well, one way to do this is to use intermediate steps. To do this, you first create a temporary data frame and then use that as input to the next function, like this:\n\ndc_impacts <- filter(df, state == 'DC')\ndc_impacts_airlineTime <- select(dc_impacts, operator, time, time_of_day)\nhead(dc_impacts_airlineTime)\n\n#> # A tibble: 6 × 3\n#>   operator           time time_of_day\n#>   <chr>             <dbl> <chr>      \n#> 1 AMERICAN AIRLINES  2130 Night      \n#> 2 AMERICAN AIRLINES  2043 Night      \n#> 3 AMERICAN AIRLINES   730 Dawn       \n#> 4 AMERICAN AIRLINES  2245 Night      \n#> 5 AMERICAN AIRLINES  2150 Night      \n#> 6 AMERICAN AIRLINES  2022 Night\n\n\nThis works, but it can also clutter up your workspace with lots of objects with different names.\nAnother approach is to use pipes, which is a more recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nThe pipe operator is %>% and comes from the magrittr package, which is installed automatically with dplyr. If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac. Here’s the same thing as the previous example but with pipes:\n\ndf %>%\n    filter(state == 'DC') %>%\n    select(operator, time, time_of_day) %>%\n    head()\n\n#> # A tibble: 6 × 3\n#>   operator           time time_of_day\n#>   <chr>             <dbl> <chr>      \n#> 1 AMERICAN AIRLINES  2130 Night      \n#> 2 AMERICAN AIRLINES  2043 Night      \n#> 3 AMERICAN AIRLINES   730 Dawn       \n#> 4 AMERICAN AIRLINES  2245 Night      \n#> 5 AMERICAN AIRLINES  2150 Night      \n#> 6 AMERICAN AIRLINES  2022 Night\n\n\nIn the above code, we use the pipe to send the df data frame first through filter() to keep only rows from DC, and then through select() to keep only the columns operator, time, and time_of_day.\nSince %>% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions.\nConsider reading the %>% operator as the words “…and then…”. For instance, in the above example I would read the code as “First, filter to only data from DC, and then select the columns operator, time, and time_of_day, and then show the first 6 rows.”\nHere’s another analogy:\nWithout Pipes:\n\nleave_house(get_dressed(get_out_of_bed(wake_up(me))))\n\nWith Pipes:\n\nme %>%\n    wake_up %>%\n    get_out_of_bed %>%\n    get_dressed %>%\n    leave_house\n\nIn the above example, adding pipes makes the flow of operations easier to read from left to right, with the %>% operator reading as “…and then…”\nIf you want to create a new object with the output of a “pipeline”, you just put the object name at the start of the first pipe:\n\ndc_impacts <- df %>%\n    filter(state == 'DC') %>%\n    select(operator, time, time_of_day)\nhead(dc_impacts)\n\n#> # A tibble: 6 × 3\n#>   operator           time time_of_day\n#>   <chr>             <dbl> <chr>      \n#> 1 AMERICAN AIRLINES  2130 Night      \n#> 2 AMERICAN AIRLINES  2043 Night      \n#> 3 AMERICAN AIRLINES   730 Dawn       \n#> 4 AMERICAN AIRLINES  2245 Night      \n#> 5 AMERICAN AIRLINES  2150 Night      \n#> 6 AMERICAN AIRLINES  2022 Night\n\n\n\n12.2.5 Sort rows with arrange()\n\nUse the arrange() function to sort a data frame by a column. For example, if you wanted to view the least expensive accidents, you could arrange the data frame by the variable cost_repairs_infl_adj:\n\n# Arrange by least expensive accident\ndf %>%\n    arrange(cost_repairs_infl_adj)\n\n#> # A tibble: 56,978 × 21\n#>   incident_date       state airport_id airport  opera…¹ atype type_…² speci…³\n#>   <dttm>              <chr> <chr>      <chr>    <chr>   <chr> <chr>   <chr>  \n#> 1 2013-09-05 00:00:00 MI    KFNT       BISHOP … SOUTHW… B-73… D       UNKBS  \n#> 2 2011-04-17 00:00:00 TX    KDFW       DALLAS/… AMERIC… MD-80 D       UNKBS  \n#> 3 2018-07-10 00:00:00 NM    KABQ       ALBUQUE… SOUTHW… B-73… D       UNKBL  \n#> 4 2017-10-31 00:00:00 PA    KPIT       PITTSBU… AMERIC… B-73… D       UNKBS  \n#> 5 2014-01-17 00:00:00 UT    KSLC       SALT LA… SOUTHW… B-73… D       J21    \n#> 6 2006-04-28 00:00:00 TX    KIAH       GEORGE … UNITED… B-73… D       UNKBM  \n#> # … with 56,972 more rows, 13 more variables: species <chr>, damage <chr>,\n#> #   num_engs <dbl>, incident_month <dbl>, incident_year <dbl>,\n#> #   time_of_day <chr>, time <dbl>, height <dbl>, speed <dbl>,\n#> #   phase_of_flt <chr>, sky <chr>, precip <chr>,\n#> #   cost_repairs_infl_adj <dbl>, and abbreviated variable names ¹​operator,\n#> #   ²​type_eng, ³​species_id\n\n\nTo sort in descending order, add the desc() function inside the arrange() function. For example, here are the most expensive accidents:\n\n# Arrange by most expensive accident\ndf %>%\n    arrange(desc(cost_repairs_infl_adj))\n\n#> # A tibble: 56,978 × 21\n#>   incident_date       state airport_id airport  opera…¹ atype type_…² speci…³\n#>   <dttm>              <chr> <chr>      <chr>    <chr>   <chr> <chr>   <chr>  \n#> 1 2009-02-03 00:00:00 CO    KDEN       DENVER … UNITED… B-75… D       K3201  \n#> 2 2007-11-22 00:00:00 N/A   LFMN       NICE CO… DELTA … B-76… D       NE138  \n#> 3 2011-09-26 00:00:00 CO    KDEN       DENVER … UNITED… B-75… D       K3302  \n#> 4 2017-07-11 00:00:00 CO    KDEN       DENVER … UNITED… B-73… D       K3302  \n#> 5 2008-10-25 00:00:00 UT    KSLC       SALT LA… DELTA … DC-9… D       K3312  \n#> 6 2011-07-30 00:00:00 CA    KBUR       BOB HOP… SOUTHW… B-73… D       O2111  \n#> # … with 56,972 more rows, 13 more variables: species <chr>, damage <chr>,\n#> #   num_engs <dbl>, incident_month <dbl>, incident_year <dbl>,\n#> #   time_of_day <chr>, time <dbl>, height <dbl>, speed <dbl>,\n#> #   phase_of_flt <chr>, sky <chr>, precip <chr>,\n#> #   cost_repairs_infl_adj <dbl>, and abbreviated variable names ¹​operator,\n#> #   ²​type_eng, ³​species_id\n\n\n\n12.2.6 Create new variables with mutate()\n\n\nYou will often need to create new columns based on the values in existing columns. For this use mutate(). For example, let’s create a new variable converting the height variable from feet to miles:\n\ndf %>%\n    mutate(height_miles = height / 5280) %>%\n    select(height, height_miles)\n\n#> # A tibble: 56,978 × 2\n#>   height height_miles\n#>    <dbl>        <dbl>\n#> 1    700        0.133\n#> 2      0        0    \n#> 3     NA       NA    \n#> 4     NA       NA    \n#> 5     NA       NA    \n#> 6     NA       NA    \n#> # … with 56,972 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\ndf %>%\n    mutate(height_miles = height / 5280,\n           height_half_miles = height_miles / 2) %>%\n    select(height, height_miles, height_half_miles)\n\n#> # A tibble: 56,978 × 3\n#>   height height_miles height_half_miles\n#>    <dbl>        <dbl>             <dbl>\n#> 1    700        0.133            0.0663\n#> 2      0        0                0     \n#> 3     NA       NA               NA     \n#> 4     NA       NA               NA     \n#> 5     NA       NA               NA     \n#> 6     NA       NA               NA     \n#> # … with 56,972 more rows\n\n\nYou’ll notice that the variables created have a lot of NAs - that’s because there are missing data. If you wanted to remove those, you could insert a filter() in the pipe chain:\n\ndf %>%\n    filter(!is.na(height)) %>%\n    mutate(height_miles = height / 5280) %>%\n    select(height, height_miles)\n\n#> # A tibble: 38,940 × 2\n#>   height height_miles\n#>    <dbl>        <dbl>\n#> 1    700        0.133\n#> 2      0        0    \n#> 3    600        0.114\n#> 4      0        0    \n#> 5      0        0    \n#> 6      0        0    \n#> # … with 38,934 more rows\n\n\nis.na() is a function that determines whether something is an NA. The ! symbol negates the result, so we’re asking for every row where weight is not an NA."
  },
  {
    "objectID": "data-wrangling.html#split-apply-combine",
    "href": "data-wrangling.html#split-apply-combine",
    "title": "12  Data Wrangling",
    "section": "\n12.3 Split-apply-combine",
    "text": "12.3 Split-apply-combine\nMany data analysis tasks can be approached using the split-apply-combine paradigm:\n\nSplit the data into groups\nApply some analysis to each group\nCombine the results.\n\ndplyr makes this very easy through the use of the group_by() function.\n\n12.3.1 The group_by() function\n\nThe group_by() function enables you to perform operations across groups within the data frame. It is typically used by inserting it in the “pipeline” before the desired group operation. For example, if we wanted to add a a new column that computed the mean height of reported wildlife impacts for each state, we could insert group_by(state) in the pipeline:\n\ndf %>%\n    filter(!is.na(height)) %>%\n    group_by(state) %>%          # Here we're grouping by state\n    mutate(mean_height = mean(height)) %>%\n    select(state, mean_height)\n\n#> # A tibble: 38,940 × 2\n#> # Groups:   state [59]\n#>   state mean_height\n#>   <chr>       <dbl>\n#> 1 FL           892.\n#> 2 IN           719.\n#> 3 FL           892.\n#> 4 FL           892.\n#> 5 TX          1177.\n#> 6 NY           937.\n#> # … with 38,934 more rows\n\n\nYou’ll see that the same value for mean_height is reported for the same states (e.g. the mean height in Florida is 892 ft).\n\n12.3.2 The summarize() function\n\nThe group_by() function is often used together with summarize(), which collapses each group into a single-row summary of that group. For example, we collapse the result of the previous example by using summarise() instead of mutate():\n\ndf %>%\n    filter(!is.na(height)) %>%\n    group_by(state) %>%\n    summarise(mean_height = mean(height))\n\n#> # A tibble: 59 × 2\n#>   state mean_height\n#>   <chr>       <dbl>\n#> 1 AB           327.\n#> 2 AK           334.\n#> 3 AL           861.\n#> 4 AR           968.\n#> 5 AZ          2134.\n#> 6 BC           497.\n#> # … with 53 more rows\n\n\nYou can also group by multiple columns - here let’s group by state and the airline:\n\ndf %>%\n    filter(!is.na(height)) %>%\n    group_by(state, operator) %>%\n    summarise(mean_height = mean(height))\n\n#> `summarise()` has grouped output by 'state'. You can override using the\n#> `.groups` argument.\n\n\n#> # A tibble: 213 × 3\n#> # Groups:   state [59]\n#>   state operator          mean_height\n#>   <chr> <chr>                   <dbl>\n#> 1 AB    AMERICAN AIRLINES        318.\n#> 2 AB    UNITED AIRLINES          350 \n#> 3 AK    AMERICAN AIRLINES          0 \n#> 4 AK    DELTA AIR LINES          414.\n#> 5 AK    UNITED AIRLINES          311.\n#> 6 AL    AMERICAN AIRLINES       1038.\n#> # … with 207 more rows\n\n\nNotice that in the above examples I’ve kept the early filter to drop NAs. This is important when performing summarizing functions like mean() or sum(). If NAs are present, the result will also be NA:\n\ndf %>%\n    group_by(state) %>%\n    summarise(mean_height = mean(height))\n\n#> # A tibble: 59 × 2\n#>   state mean_height\n#>   <chr>       <dbl>\n#> 1 AB            NA \n#> 2 AK           334.\n#> 3 AL            NA \n#> 4 AR            NA \n#> 5 AZ            NA \n#> 6 BC            NA \n#> # … with 53 more rows\n\n\nOnce the data are grouped, you can also summarize multiple variables at the same time (and not necessarily on the same variable). For instance, you could add two more columns computing the minimum and maximum height:\n\ndf %>%\n    filter(!is.na(height)) %>%\n    group_by(state, operator) %>%\n    summarise(mean_height = mean(height),\n              min_height = min(height),\n              max_height = max(height))\n\n#> `summarise()` has grouped output by 'state'. You can override using the\n#> `.groups` argument.\n\n\n#> # A tibble: 213 × 5\n#> # Groups:   state [59]\n#>   state operator          mean_height min_height max_height\n#>   <chr> <chr>                   <dbl>      <dbl>      <dbl>\n#> 1 AB    AMERICAN AIRLINES        318.          0       1300\n#> 2 AB    UNITED AIRLINES          350           0       1400\n#> 3 AK    AMERICAN AIRLINES          0           0          0\n#> 4 AK    DELTA AIR LINES          414.          0       1700\n#> 5 AK    UNITED AIRLINES          311.          0       1200\n#> 6 AL    AMERICAN AIRLINES       1038.          0      11300\n#> # … with 207 more rows\n\n\n\n12.3.3 Counting\nOften times you will want to know the number of observations found for each variable or combination of variables. One way to do this is to use the group_by() and summarise() functions in combination. For example, here is the number of observations for each aircraft engine type:\n\ndf %>%\n    group_by(type_eng) %>%\n    summarise(count = n())\n\n#> # A tibble: 5 × 2\n#>   type_eng count\n#>   <chr>    <int>\n#> 1 A            2\n#> 2 C           34\n#> 3 D        56705\n#> 4 F            3\n#> 5 <NA>       234\n\n\nSince this is such a common task, dplyr provides the count() function to do the same thing:\n\ndf %>%\n    count(type_eng)\n\n#> # A tibble: 5 × 2\n#>   type_eng     n\n#>   <chr>    <int>\n#> 1 A            2\n#> 2 C           34\n#> 3 D        56705\n#> 4 F            3\n#> 5 <NA>       234\n\n\nFor convenience, count() also provides the sort argument:\n\ndf %>%\n    count(type_eng, sort = TRUE)\n\n#> # A tibble: 5 × 2\n#>   type_eng     n\n#>   <chr>    <int>\n#> 1 D        56705\n#> 2 <NA>       234\n#> 3 C           34\n#> 4 F            3\n#> 5 A            2\n\n\nYou can also count the combination of variables by providing more than one column name to count():\n\ndf %>%\n    count(type_eng, num_engs, sort = TRUE)\n\n#> # A tibble: 10 × 3\n#>   type_eng num_engs     n\n#>   <chr>       <dbl> <int>\n#> 1 D               2 53652\n#> 2 D               3  2753\n#> 3 D               4   299\n#> 4 <NA>           NA   232\n#> 5 C               2    34\n#> 6 F               2     3\n#> # … with 4 more rows\n\n\nHmm, looks like most reported wildlife impacts involve planes with 2 D-type engines."
  },
  {
    "objectID": "data-wrangling.html#exporting-data",
    "href": "data-wrangling.html#exporting-data",
    "title": "12  Data Wrangling",
    "section": "\n12.4 Exporting data",
    "text": "12.4 Exporting data\nNow that you have learned how to use dplyr to extract information from or summarize your raw data, you may want to export these new data sets. Similar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nImportant: Before using write_csv(), create a new folder called “data_output” and put it in your R Project folder. In general, you should never write generated datasets in the same directory as your raw data. The “data” folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it.\nLet’s save one of the summary data frames from the earlier examples where we computed the min, mean, and max heights of impacts by each state and airline:\n\nheightSummary <- df %>%\n    filter(!is.na(height)) %>%\n    group_by(state, operator) %>%\n    summarise(mean_height = mean(height),\n              min_height = min(height),\n              max_height = max(height))\n\n#> `summarise()` has grouped output by 'state'. You can override using the\n#> `.groups` argument.\n\n\nSave the the new heightSummary data frame as a CSV file in your “data_output” folder:\n\nwrite_csv(heightSummary, path = file.path('data_output', 'heightSummary.csv')"
  },
  {
    "objectID": "data-wrangling.html#tips",
    "href": "data-wrangling.html#tips",
    "title": "12  Data Wrangling",
    "section": "\n12.5 Tips",
    "text": "12.5 Tips\nYou will often need to create new variables based on a condition. To do this, you can use the if_else() function. Here’s the general syntax:\n\nif_else(<condition>, <if TRUE>, <else>)\n\nThe first argument is a condition. If the condition is TRUE, then the value given to the second argument will be used; if not, then the third argument value will be used.\nHere’s an example of creating a variable to determine which months in the wildlife impacts data are in the summer:\n\ndf %>%\n    mutate(\n        summer_month = if_else(incident_month %in% c(6, 7, 8), TRUE, FALSE))\n\nOf course, in this particular case the if_else() function isn’t even needed because the condition returns TRUE and FALSE values. However, if you wanted to extend this example to determine all four seasons, you could use a series of nested if_else() functions:\n\ndf %>%\n    mutate(season =\n        if_else(\n            incident_month %in% c(3, 4, 5), 'Spring',\n        if_else(\n            incident_month %in% c(6, 7, 8), 'Summer',\n        if_else(\n            incident_month %in% c(9, 10, 11), 'Fall', 'Winter'))))\n\nNote: The Base R version of this function is ifelse(), but I recommend using the dplyr version, if_else(), as it is a stricter function."
  },
  {
    "objectID": "data-wrangling.html#page-sources",
    "href": "data-wrangling.html#page-sources",
    "title": "12  Data Wrangling",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\n\nData Analysis and Visualization in R for Ecologists, by François Michonneau & Auriel Fournier. Zenodo: http://doi.org/10.5281/zenodo.3264888\nThe amazing illustrations by Allison Horst"
  },
  {
    "objectID": "data-visualization.html#r-setup",
    "href": "data-visualization.html#r-setup",
    "title": "13  Data Visualization",
    "section": "\n13.1 R Setup",
    "text": "13.1 R Setup\nBefore we get started, let’s set up our analysis environment like before:\n\nOpen up your “data_analysis_tutorial” R Project that you created in the first data analysis lesson - if you didn’t do this, go back and do it now.\nCreate a new .R file (File > New File > R Script), and save it as “data_viz.R” inside your “data_analysis_tutorial” R Project folder.\nThis time, instead of downloading the data file and saving it in our data folder, let’s just read it in directly from the web!\n\n\nlibrary(readr)\nlibrary(dplyr)\ndf <- read_csv(\"https://raw.githubusercontent.com/emse-p4a-gwu/2020-Fall/master/data/north_america_bear_killings.csv\")\n\nFor this lesson, we are going to use the North American Bear Killings dataset, which was compiled by Ali Sanne from the Wikipedia page on fatal bear attacks in North America. The dataset contains recorded killings by black, brown, or polar bears from 1900 to 2019 in North America. Each row in the dataset holds information for a single incident with the following columns:\n\n\n\n\n\n\n\nVariable\nClass\nDescription\n\n\n\nname\ncharacter\nName of victim.\n\n\nage\ndouble\nAge of victim.\n\n\ngender\ncharacter\nGender of victim.\n\n\ndate\ncharacter\nDate of incident.\n\n\nmonth\ndouble\nMonth of incident.\n\n\nyear\ndouble\nYear of incident.\n\n\nwildOrCaptive\ncharacter\n“Wild” or “Captive” bear.\n\n\nlocation\ncharacter\nLocation of incident.\n\n\ndescription\ncharacter\nShort description of incident.\n\n\nbearType\ncharacter\n“Black”, “Brown”, or “Polar”\n\n\nhunter\ndouble\n1 if victim was a hunter, 0 otherwise.\n\n\ngrizzly\ndouble\n1 if bear is a Grizzly, 0 otherwise.\n\n\nhiker\ndouble\n1 if victim was a hiker, 0 otherwise.\n\n\nonlyOneKilled\ndouble\n1 if only one victim was killed, 0 otherwise.\n\n\n\nSide node: One thing I learned looking at this data is that all grizzly bears are brown bears, but not all brown bears are grizzly bears (kind of like the squares and rectangles thing).\nTo confirm that we’ve correctly loaded the data frame, let’s preview the data:\n\nglimpse(df)\n\n#> Rows: 166\n#> Columns: 14\n#> $ name          <chr> \"Mary Porterfield\", \"Wilie Porterfield\", \"Henry Porte…\n#> $ age           <dbl> 3, 5, 7, 18, 1, 61, 60, 9, 52, NA, 60, 56, 70, 5, 11,…\n#> $ gender        <chr> \"female\", \"male\", \"male\", \"male\", NA, \"male\", \"male\",…\n#> $ date          <chr> \"19/05/1901\", \"19/05/1901\", \"19/05/1901\", \"24/11/1906…\n#> $ month         <dbl> 5, 5, 5, 11, 10, 9, 6, 8, 9, 10, 6, 7, 10, 10, 10, 7,…\n#> $ year          <dbl> 1901, 1901, 1901, 1906, 1908, 1916, 1922, 1929, 1929,…\n#> $ wildOrCaptive <chr> \"Wild\", \"Wild\", \"Wild\", \"Wild\", \"Captive\", \"Wild\", \"W…\n#> $ location      <chr> \"Job, West Virginia\", \"Job, West Virginia\", \"Job, Wes…\n#> $ description   <chr> \"The children were gathering flowers near their home …\n#> $ bearType      <chr> \"Black\", \"Black\", \"Black\", \"Black\", \"Black\", \"Brown\",…\n#> $ hunter        <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ grizzly       <dbl> 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,…\n#> $ hiker         <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n#> $ onlyOneKilled <dbl> 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n\n\nLook’s good - let’s start making some plots!"
  },
  {
    "objectID": "data-visualization.html#basic-plots-in-r",
    "href": "data-visualization.html#basic-plots-in-r",
    "title": "13  Data Visualization",
    "section": "\n13.2 Basic plots in R",
    "text": "13.2 Basic plots in R\nR has a number of built-in tools for basic graph types. We will only cover two here because they are so common and convenient: scatterplots and histograms.\n\n13.2.1 Scatterplots with plot()\n\nA scatter plot provides a graphical view of the relationship between two variables. Typically these are used for “continuous” variables, like time, age, money, etc…things that are not categorical in nature (as opposed to “discrete” variables, like nationality). Here’s a scatterplot of the age of the bear killing victims over time:\n\nplot(x = df$year, y = df$age)\n\n\n\n\n\n\n\nThe basic inputs to the plot() function are x and y, which must be vectors of the same length. You can customize many features (fonts, colors, axes, shape, titles, etc.) through graphic options. Here’s the same plot with a few customizations:\n\nplot(x    = df$year,\n     y    = df$age,\n     col  = 'darkblue', # \"col\" changes the point color\n     pch  = 19, # \"pch\" changes the point shape\n     main = \"Age of bear killing victims over time\",\n     xlab = \"Year\",\n     ylab = \"Age\")\n\n\n\n\n\n\n\nLooks like bear killings are becoming more frequent over time (hmm, why might that be?), though pretty evenly-distributed across age (I guess bears will kill you regardless of your age).\n\n13.2.2 Histograms with hist()\n\nThe histogram is one of the most common ways to visualize the distribution of a variable. The hist() function takes just one variable: x. Here’s a histogram of the month variable:\n\nhist(x = df$month)\n\n\n\n\n\n\n\nAs you might expect, most bear attacks occur during the summer months, when parks get more visitors. As with the plot() function, you can customize a lot of the histogram features. One common customization is to modify the number of “bins” in the histogram by changing the breaks argument. Here we’ll fix the number of bins to 12 - one for each month:\n\nhist(x      = df$month,\n     breaks = 12,\n     col    = 'darkred',\n     main   = \"Distribution of bear killings by month\",\n     xlab   = \"Month\",\n     ylab   = \"Count\")"
  },
  {
    "objectID": "data-visualization.html#advanced-figures-with-ggplot2",
    "href": "data-visualization.html#advanced-figures-with-ggplot2",
    "title": "13  Data Visualization",
    "section": "\n13.3 Advanced figures with ggplot2\n",
    "text": "13.3 Advanced figures with ggplot2\n\n[Art by Allison Horst]\nWhile Base R plot functions are useful for making simple, quick plots, many R users have adopted the ggplot2 package as their primary tool for visualizing data.\n\n13.3.1 The Grammar of Graphics\nThe ggplot2 library is built on the “Grammar of Graphics” concept developed by Leland Wilkinson. A “grammar of graphics” (that’s what the “gg” in “ggplot2” stands for) is a framework that uses layers to describe and construct visualizations or graphics in a structured manner. Here’s a visual summary of the concept:\n\n\n\nWe will start using ggplot2 by re-creating some of the above plots, but using ggplot functions to get a feel for the syntax. But first, install and load the library:\n\nlibrary(ggplot2)\n\n\n13.3.2 A blank slate\nThe ggplot() function is used to initialize the basic graph structure, and then we add layers to it. The basic idea is that you specify different parts of the plot, and add them together using the + operator. We will start with a blank plot and will add layers as we go along:\n\nggplot(data = df)\n\n\n\n\n\n\n\n\n13.3.3 Geoms and aesthetics\nGeometric objects (called “geoms”) are the shapes we put on a plot (e.g. points, bars, etc.). You can have an unlimited number of layers, but at a minimum a plot must have at least one geom. Examples include:\n\n\ngeom_point() makes a scatter plot by adding a layer of points.\n\ngeom_line() adds a layer of lines connecting data points.\n\ngeom_col() adds bars for bar charts.\n\ngeom_histogram() makes a histogram.\n\ngeom_boxplot() adds boxes for boxplots.\n\nEach type of geom usually has a required set of aesthetics to be set, and usually accepts only a subset of all aesthetics. Aesthetic mappings are set with the aes() function. Examples include:\n\n\nx and y (the position on the x and y axes)\n\ncolor (“outside” color, like the line around a bar)\n\nfill (“inside” color, like the color of the bar itself)\n\nshape (the type of point, like a dot, square, triangle, etc.)\n\nlinetype (solid, dashed, dotted etc.)\n\nsize (of geoms)\n\n13.3.4 Scatterplots with geom_point()\n\nNow that we know what geoms and aesthetics are, let’s put them to practice by making a scatterplot. To start, we will add the geom_point() geom and we’ll set the position for the x- and y-axis inside the aes() function:\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age))\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\nNotice how we’ve “added” the geom_point() layer to the previous blank slate. Also note that the names we used to define the x and y axes are column names in the data frame, df. These must be placed inside the aes() function, which tells ggplot to look in df for those columns.\nIf I wanted to change the point color, I could add that inside the geom_point() layer:\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age), color = \"blue\")\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\nBut I could also map one of my variables to the point color by placing the color variable inside the aes() function:\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age, color = gender))\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n13.3.5 Bar charts with geom_col()\n\nI recommend using the geom_col() layer to create bar charts, which are great for comparing different numerical values across a categorical variable. One of the simplest things to show with bars is the count of how many observations you have. You can compute this by using the count() function, and then use the resulting data frame to create bars of those counts:\n\n# Compute the counts\nmonthCounts <- df %>%\n  count(month)\n\n# Create the bar chart\nggplot(data = monthCounts) +\n    geom_col(aes(x = month, y = n))\n\n\n\n\n\n\n\nAlternatively, you could use the %>% operator to pipe the results of a summary data frame directly into ggplot:\n\ndf %>%\n  count(month) %>%  # Compute the counts\n  ggplot() +\n  geom_col(aes(x = month, y = n)) # Create the bar chart\n\n\n\n\n\n\n\nJust like how we mapped the point color to a variable in scatter plots, you can map the bar color to a variable with bar charts using the fill argument in the aes() call. For example, here’s the same bar chart of the count of observations with the bar colors representing the type of bear.\n\ndf %>%\n  count(month, bearType) %>%  # Compute the counts for month and bear type\n  ggplot() +\n  geom_col(aes(x = month, y = n, fill = bearType)) # Change the bar color based on bear type\n\n\n\n\n\n\n\nHmm, looks like brown bears are the most frequent killers, though black bears are a close second.\nYou can plot variables other than the count. For example, here is a plot of the mean age of the victim in each year:\n\ndf %>%\n  filter(!is.na(age)) %>%\n  group_by(year) %>%\n  summarise(meanAge = mean(age)) %>% # Compute the mean age in each year\n  ggplot() +\n  geom_col(aes(x = year, y = meanAge))"
  },
  {
    "objectID": "data-visualization.html#customizing-your-ggplot",
    "href": "data-visualization.html#customizing-your-ggplot",
    "title": "13  Data Visualization",
    "section": "\n13.4 Customizing your ggplot",
    "text": "13.4 Customizing your ggplot\nThere are lots of ways to tweak your ggplot to make it more aesthetically pleasing and easier for others to understand. We’ll cover just two here: labels and themes.\n\n13.4.1 Labels\nYou can change the labels of your plot by adding the labs() layer:\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age, color = gender)) +\n    labs(x = \"Year\",\n         y = \"Age\",\n         color = \"Gender\",\n         title = \"Age of bear killing victims over time\",\n         subtitle = \"A subtitle\",\n         caption = \"Data source: Wikipedia\")\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\nThe labs() layer enables you to modify the labels of any of the variables that you have mapped in your aes() call, as well as some other labels like the title, subtitle, and caption.\n\n13.4.2 Themes\nAdding theme layers can change some global aspects of the plot, such as the background color, grid lines, legend appearance, etc. There are many themes to choose from, but using simple themes like theme_bw() or theme_minimal() often improves the plot from the default theme settings:\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age)) +\n    theme_minimal()\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\nThere are LOTS of other themes from external packages as well. Some of my favorites are theme_ipsum() and theme_ft_rc() from the hrbrthemes package:\n\nlibrary(hrbrthemes)\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age)) +\n    theme_ipsum()\n\n\n\n\n\nlibrary(hrbrthemes)\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age)) +\n    theme_ft_rc()\n\n\n\n\nWant to make a plot look fancy like those in the Economist magazine? Try theme_economist() from the ggthemes library:\n\nlibrary(ggthemes)\n\nggplot(data = df) +\n    geom_point(aes(x = year, y = age)) +\n    theme_economist()\n\n#> Warning: Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "data-visualization.html#saving-figures",
    "href": "data-visualization.html#saving-figures",
    "title": "13  Data Visualization",
    "section": "\n13.5 Saving figures",
    "text": "13.5 Saving figures\nThe first (and easiest) is to export directly from the RStudio ‘Plots’ panel, by clicking on Export when the image is plotted. This will give you the option of .png or .pdf and selecting the directory to which you wish to save it to. I strongly recommend you save images as .pdf types as these won’t pixelate when you change the image size.\nAnother easy way to save a ggplot figure is to use the ggsave() function. First, create your plot and save it as an object:\n\nscatterPlot <- ggplot(data = df) +\n    geom_point(aes(x = year, y = age))\n\nThen save the plot using ggsave() (make sure you create a folder called “plots” in which to save your plot):\n\nggsave(filename = here('data', 'scatterPlot.pdf'),\n       plot   = scatterPlot,\n       width  = 6,\n       height = 4)"
  },
  {
    "objectID": "data-visualization.html#other-resources",
    "href": "data-visualization.html#other-resources",
    "title": "13  Data Visualization",
    "section": "\n13.6 Other resources",
    "text": "13.6 Other resources\nWhile the ggplot2 library offers a wide variety of options for customizing your plots, remembering exactly how to do specific tasks (like changing the color of a line, or changing the position of a legend) can be difficult. Fortunately, there are wonderful resources for looking up all the tricks to make the perfect ggplot. Here are a few:\n\nRStudio ggplot2 Cheatsheet\nTidyverse ggplot2 reference guide\nR Cookbook for ggplot2\nTop 50 ggplot2 visualizations\n\nFor more resources, check out the data viz resource page"
  },
  {
    "objectID": "data-visualization.html#page-sources",
    "href": "data-visualization.html#page-sources",
    "title": "13  Data Visualization",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\n\nData Analysis and Visualization in R alpha, by Data Carpentry contributors."
  },
  {
    "objectID": "webscraping.html",
    "href": "webscraping.html",
    "title": "14  Introduction",
    "section": "",
    "text": "This is a Quarto book."
  },
  {
    "objectID": "extensions.html",
    "href": "extensions.html",
    "title": "Extensions",
    "section": "",
    "text": "The goal of this section is to…"
  },
  {
    "objectID": "monte-carlo-methods.html#what-is-monte-carlo-simulation",
    "href": "monte-carlo-methods.html#what-is-monte-carlo-simulation",
    "title": "15  Monte Carlo Methods",
    "section": "\n15.1 What is Monte Carlo simulation?",
    "text": "15.1 What is Monte Carlo simulation?\n\n15.1.1 Basic idea\nMonte Carlo simulation uses (pseudo)random numbers to solve (not-so-random) problems. The general approach goes like this:\n\nRun a series of trials.\nIn each trial, simulate an event (e.g. a coin toss, a dice roll, etc.).\nCount the number of successful trials.\nGuess that the Expected Odds \\(\\simeq\\) Observed Odds = \\(\\frac{\\text{# Successful Trials}}{\\text{# Total Trials}}\\)\n\n\nFor many applications, Monte Carlo simulations result in a sufficiently accurate result with a reasonable amount of trials (~ 100,000). You can always improve your accuracy with more trials, but that comes at the expense of increased run time. To summarize:\n\nAs # of trials increases, observed odds –> expected odds.\nMore trials –> more accurate (+ more time).\n\n15.1.2 Why the name “Monte Carlo”?\nThe name “Monte Carlo” comes from the (pseudo)random nature of the simulation process. Running a series of trials is similar to how many gambling games work in casinos, and Monte Carlo is famous for gambling. Of course, in the casinos the odds are always slightly in the favor of the house, so after millions of trials the odds are that the house will win more money than the gamblers.\n\n15.1.3 Why even do this?\nMany problems have “closed-form” solutions, meaning they can be solved with math alone. But there are also many problems for which no known closed-form solution exists. Integration is a classic example - there are many integrals for which a purely mathematical solution cannot be determined. However, solutions can be approximated using simulation.\nR comes with many tools for running (pseudo)random simulations, which is one reason R is such a popular programming language for people who build and work with statistical models that involve simulations."
  },
  {
    "objectID": "monte-carlo-methods.html#monte-carlo-integration",
    "href": "monte-carlo-methods.html#monte-carlo-integration",
    "title": "15  Monte Carlo Methods",
    "section": "\n15.2 Monte Carlo integration",
    "text": "15.2 Monte Carlo integration\nIntegration is ultimately about computing the area below the curve of a function. Let’s take a simple example - suppose we want to find the integral from 3 to 7 of the following function:\n\\[f(x) = x^2\\]\nThat is, we want to compute the area under the curve of \\(x^2\\) between \\(3 < x < 7\\). Here’s what that looks like:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne way to estimate the shaded area is to draw a bunch of random points inside a rectangle in the x-y plane that contains the shaded area and then count how many fall below the function line. So we’re going to randomly draw points inside this box:\n\n\n\n\n\n\n\n\nLet’s simulate some random points inside the box:\n\nnumTrials <- 100000\n# The function runif() samples from a \"uniform\" distribution\nx <- runif(numTrials, min = 3, max = 7) # Values of x between 3 and 7\ny <- runif(numTrials, min = 0, max = 7^2) # Values of y between 0 and 7^2\n\nNow that we have our points, we can use them to estimate the area under the curve. The logic here is that the ratio of points below the curve to the total number of points will be equal to the ratio of the area under \\(f(x)\\) to the total area of the rectangle. That is:\n\\[\\frac{\\text{# Points Under Curve}}{\\text{# Total Points}} = \\frac{\\text{Area Under Curve}}{\\text{Area of Rectangle}}\\]\nSo, to get the area under the curve, we need to compute the area of the rectangle and multiply it by \\((\\text{# Points Under Curve}) / (\\text{# Total Points})\\). We know the total area of the rectangle is its length (\\((7 - 3) = 4\\)) times its height (\\(7^2\\)), which is \\(4 * 49 = 196\\). So the area under the curve should be 196 times the ratio of points under the curve to the total number of points. Let’s write the code!\n\n# Determine which y points are less than or equal to x^2:\nbelowCurve <- y <= x^2 # This will create a vector of TRUE and FALSE values\n# Compute the ratio of points below the curve:\nratio <- sum(belowCurve) / numTrials\ntotalArea <- (7 - 3) * 7^2 # Rectangle length x height = 196\nareaUnderCurve <- ratio * totalArea\nareaUnderCurve\n\n#> [1] 105.2363\n\n\nSo, using Monte Carlo simulation with 100,000 points, we estimate that the area under the curve is 105.23632. How’d we do? Well, if you’re familiar with calculus, the integral of \\(f(x) = x^2\\) has a closed-form solution (\\(\\frac{x^3}{3} + C\\)), so we can check our estimate against the pure-math solution:\n\\[\\int_{3}^{7} x^2 \\mathrm{dx} = \\left ( \\frac{x^3}{3} \\right ) \\Big|_3^7 = \\frac{7^3}{3} - \\frac{3^3}{3} = 105.33\\bar{3}\\]\n\n\n\nSo our estimate error is: 105.333 - 105.23632 = 0.0970133.\nThat’s an error of just 0.09 % - not bad!"
  },
  {
    "objectID": "monte-carlo-methods.html#monte-carlo-pi",
    "href": "monte-carlo-methods.html#monte-carlo-pi",
    "title": "15  Monte Carlo Methods",
    "section": "\n15.3 Monte Carlo \\(\\pi\\)\n",
    "text": "15.3 Monte Carlo \\(\\pi\\)\n\nNow let’s look at something a bit trickier - approximating \\(\\pi\\)!\nWatch this quick video to see a summary of how this works (…I hope you like lounge music)\n\n\nNow let’s approximate \\(\\pi\\) ourselves! Let’s start with some basic geometry.\nThe area of a circle is:\n\n\\(A_{circle} = \\pi r^2\\)\n\nIf we draw a square containing that circle, its area will be:\n\n\\(A_{square} = 4r^2\\)\n\nThis is because each side of the square is simply \\(2r\\), as can be seen in this image:\n\nKnowing these two equations for the areas of a circle and square, we can compute \\(\\pi\\) by taking the ratio, \\(R\\), of the area of a circle to that of a square containing that circle:\n\\(R = \\dfrac{\\pi r^2}{4r^2} = \\dfrac{\\pi}{4}\\)\nSo to compute \\(\\pi\\), all we need to do is multiply 4 times the ratio of the area of the circle to that of the square. Just like with integration, we can approximate that ratio by simulating lots of points in the square and then simply counting the number that fall inside the circle.\nLet’s write the code!\nFirst, generate lots of random points in a square. For this example, we’ll use a square with side length of 1 centered at (x, y) = (0, 0), so we need to draw random points between x = (-0.5, 0.5) and y = (-0.5, 0.5):\n\nnumTrials <- 1000\npoints <- data.frame(\n    x = runif(numTrials, -0.5, 0.5),\n    y = runif(numTrials, -0.5, 0.5))\nhead(points)\n\n#>              x            y\n#> 1  0.229506132  0.139484990\n#> 2 -0.007594905 -0.002580851\n#> 3  0.109975740 -0.202333914\n#> 4 -0.219826613  0.163189993\n#> 5 -0.011846287  0.301705838\n#> 6 -0.175026551 -0.030729181\n\n\nFor this example, we’re putting the points in a data frame to make it easier to work with. Now that we have random x and y points, let’s compute the radius to each point (the distance from (x, y) = (0, 0)) so we can determine which points fall inside the circle (which has a radius of 0.5):\n\nlibrary(dplyr)\npoints <- points %>%\n    mutate(\n        radius = sqrt(x^2 + y^2),\n        pointInCircle = ifelse(radius <= 0.5, TRUE, FALSE))\n\nJust to make sure we correctly labeled the points, let’s plot them, coloring them based on the pointInCircle variable we just created:\n\nlibrary(ggplot2)\nggplot(points) +\n    geom_point(aes(x = x, y = y, color = pointInCircle), size = 0.7) +\n    theme_minimal()\n\n\n\n\n\n\n\nLooks like we correctly labeled the points! Now we have everything we need to estimate \\(\\pi\\)!\n\nratio <- sum(points$pointInCircle) / nrow(points)\npiApprox <- 4 * ratio\npiApprox\n\n#> [1] 3.084\n\n\n\n\n\nSo our estimate error is: 3.1415 - 3.084 = -0.0575927.\nThat’s an error of just 1.83 % - not bad for only 1,000 points!\nTo get an even better estimate of \\(\\pi\\), we can increase N. Let’s see what we get with 100,000 trials:\n\nnumTrials <- 100000\npoints <- data.frame(\n    x = runif(numTrials, -0.5, 0.5),\n    y = runif(numTrials, -0.5, 0.5)) %>%\n    mutate(\n        radius = sqrt(x^2 + y^2),\n        pointInCircle = ifelse(radius <= 0.5, TRUE, FALSE))\nratio <- sum(points$pointInCircle) / nrow(points)\npiApprox <- 4 * ratio\npiApprox\n\n#> [1] 3.13844\n\n# Compute error:\nerror <- piApprox - pi\npercentError <- round(100*abs(error / pi), 2)\npercentError\n\n#> [1] 0.1\n\n\nBy increasing the number of trials from 1,000 to 100,000, we improved our estimate error from 1.83 % to 0.1 %!"
  },
  {
    "objectID": "monte-carlo-methods.html#page-sources",
    "href": "monte-carlo-methods.html#page-sources",
    "title": "15  Monte Carlo Methods",
    "section": "Page sources",
    "text": "Page sources\nSome content on this page has been modified from other courses, including:\n\nCMU 15-112: Fundamentals of Programming, by David Kosbie & Kelly Rivers"
  },
  {
    "objectID": "python-in-r.html#getting-started-with-python-in-r",
    "href": "python-in-r.html#getting-started-with-python-in-r",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.1 Getting started with Python (in R)",
    "text": "16.1 Getting started with Python (in R)\nPython is another very popular computing language for data analysis and general purpose computing. Since R is the main language for this course, we will not cover all the many wonderous things that Python can do. Instead, we will introduce Python through the lens of how it is used for data analysis, with a particular focus on comparing its similarities and differences with R.\nWhile you can work with Python in a number of ways, we will use the reticulate to access it directly from R!\n\n16.1.1 Installation\nTo get started, install the package (remember, you only need to do this once on your computer):\n\ninstall.package('reticulate')\n\nOnce installed, load the package:\n\nlibrary(reticulate)\n\nIf you already have Python installed on your computer, you should be okay, but you may see the following message pop up in the console:\n\nWould you like to install Miniconda? [Y/n]:\n\nIf so, I recommend you go ahead and install Miniconda by typing y and pressing enter. Miniconda is a smaller version of the larger “Conda” distribution that most people use to install Python, and it is the preferred setup for using Python in R.\n\n16.1.2 Starting Python\nOnce you’ve loaded the reticulate library, use the following command to open up a Python REPL (which stands for “Read–Eval–Print-Loop”):\n\nrepl_python()\n\nNow look at your console - you should see three >>> symbols. This means you’re now using Python! (Remember, the R console has only one > symbol).\nCheck your Python version!\nAbove the >>> symbols, you should see a message indicating which version of Python you are using. It should say “Python 3….”. Python has two versions (2 and 3) - we’ll be using Python 3. If you see Python 2, then you’ll need to adjust your configuration to use Python 3. If you installed Miniconda, this should be Python 3.\n\n16.1.3 Exiting Python\nIf you want to get back to good ’ol R, just type the command exit into the Python console:\n\nexit\n\nNote that you should exit and not exit() with parenthesis."
  },
  {
    "objectID": "python-in-r.html#python-basics",
    "href": "python-in-r.html#python-basics",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.2 Python basics",
    "text": "16.2 Python basics\n\n16.2.1 Operators\nPython has all the same arithmetic (+-*/), relational (<>=), and logical (&|!) operators as R, but some of the symbols are a little different. Here’s a quick comparison of these differences:\n\n\n\nArithmetic operators\nR\nPython\n\n\n\nInteger division\n%/%\n//\n\n\nModulus\n%%\n%\n\n\nPowers\n^\n**\n\n\n\n\n\n\n\nLogical operators\nR\nPython\n\n\n\nAnd\n&\n\n& or and\n\n\n\nOr\n|\n\n| or or\n\n\n\nNot\n!\n\n! or not\n\n\n\n\n\nPython uses the same symbols &, |, and ! for assessing logical statements, but Python also supports the use of the English words and, or, and not. For example, the following statements will both return True\n\n(3 == 3) & (4 == 4)\n\n## True\n\n(3 == 3) and (4 == 4)\n\n## True\n\n16.2.2 Variable assignment\nWhile in R you can use either = or <- to assign values to objects, in Python only the = symbol can be used:\n\nvalue = 3\nvalue\n\n## 3\n\n16.2.3 Data types\nFor the most part, Python has the same data types as R: “numeric”, “string”, and “logical”. But they use different words to describe them:\n\n\n\nDescription\nR\nPython\n\n\n\nnumeric (w/decimal)\n\"double\"\n\"float\"\n\n\ninteger\n\"integer\"\n\"int\"\n\n\ncharacter\n\"character\"\n\"str\"\n\n\nlogical\n\"logical\"\n\"bool\"\n\n\n\n\nThere are three important distinctions between the languages on data types:\n\n\nLogicals: Logical statements in R use the words TRUE and FALSE (in all caps) to denote logical statements that are “True” or “False”, but in Python you only capitalize the first letter: True or False\n\n\nIntegers vs. Floats: In R, all numbers are “floats” by default (i.e. they have decimal places), so even numbers that look like integers (e.g. 3) are technically floats. In Python, numbers are integers by default unless they have decimal values (e.g. 3 is an int type, but 3.14 is a float type).\n\nNULL: In R, a value of “nothing” is represented by NULL, but in Python we use None.\n\nYou can check the type using typeof() in R or type() in Python:\n\n\nR:\n\ntypeof(3.14)\n\n#> [1] \"double\"\n\n\n\ntypeof(3L)\n\n#> [1] \"integer\"\n\n\n\ntypeof(\"3\")\n\n#> [1] \"character\"\n\n\n\ntypeof(TRUE)\n\n#> [1] \"logical\"\n\n\n\n\nPython:\n\ntype(3.14)\n\n## <class 'float'>\n\ntype(3)\n\n## <class 'int'>\n\ntype(\"3\")\n\n## <class 'str'>\n\ntype(True)\n\n## <class 'bool'>\n\n\n\n16.2.4 Coercing data types\nIn R, you can convert data types using the general form of as.something(), replacing “something” with a data type. In Python, you can simply use the data type name to convert types. Here’s a comparison:\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\nConvert to double / float:\n\n\n\nas.double(3)\n\n#> [1] 3\n\n\n\n\n\nfloat(3)\n\n## 3.0\n\n\n\n\nConvert to integer:\n\n\n\nas.integer(3.14)\n\n#> [1] 3\n\n\n\n\n\nint(3.14)\n\n## 3\n\n\n\n\nConvert to string:\n\n\n\nas.character(3.14)\n\n#> [1] \"3.14\"\n\n\n\n\n\nstr(3.14)\n\n## '3.14'\n\n\n\n\nConvert to logical:\n\n\n\nas.logical(3.14)\n\n#> [1] TRUE\n\n\n\n\n\nbool(3.14)\n\n## True\n\n\nRemember that “logical” types convert to TRUE for any number other than 0, which converts to FALSE."
  },
  {
    "objectID": "python-in-r.html#loops",
    "href": "python-in-r.html#loops",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.3 Loops",
    "text": "16.3 Loops\nPerhaps the biggest syntax difference between R and Python is that Python uses white space to define things.\nFor example, to write a loop in Python, you have to indent the second line by four character spaces, otherwise you’ll get an error. The benefits of this is that it forces you to use good style practices, and you don’t have to use the {} symbols like you do in R. The downside is that if you have a single space character missing, you’ll get an error, and sometimes that’s hard to notice.\nHere’s a comparison of loops in R and Python:\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\nfor loop:\n\n\n\nfor (i in c(1,3,5)) {\n    print(i)\n}\n\n#> [1] 1\n#> [1] 3\n#> [1] 5\n\n\n\n\n\nfor i in [1,3,5]:\n    print(i)\n\n## 1\n## 3\n## 5\n\n\n\n\nwhile loop:\n\n\n\ni <- 1\nwhile (i <= 5) {\n    print(i)\n    i <- i + 2\n}\n\n#> [1] 1\n#> [1] 3\n#> [1] 5\n\n\n\n\n\ni = 1\nwhile i <= 5:\n    print(i)\n    i = i + 2\n\n## 1\n## 3\n## 5\n\n\nOne of the things many people love about Python is just how “clean” the syntax looks. Compared to R, the Python code above is more compact and contains less distracting elements, like the “{}” symbols. You also don’t need to include () symbols on the first line.\nOther than these differences in syntax, loops are essentially the same across the two languages."
  },
  {
    "objectID": "python-in-r.html#functions",
    "href": "python-in-r.html#functions",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.4 Functions",
    "text": "16.4 Functions\nFunctions use the same “spacing” format as loops, and again the Python syntax is more compact. Here’s a comparison of the isEven(n) function:\n\n\nR:\n\nisEven <- function(n) {\n    if (n %% 2 == 0) {\n        return(TRUE)\n    }\n    return(FALSE)\n}\n\n\n\nPython:\n\ndef isEven(n):\n    if (n % 2 == 0):\n        return(True)\n    return(False)\n\n\n\nNote the difference in the ordering of the first lines. In R, you first define the function name, then you assign to that name the function and argument(s).\nIn Python, you do not use any assignment to create a function. Rather, you use the command def followed by the function name and argument(s). Here, the Python syntax is quite natural - you use the same syntax that you would use when calling the function (e.g. isEven(n)).\nNote also that the if statement in Python also uses the same general syntax of indented white space instead of using the {} symbols."
  },
  {
    "objectID": "python-in-r.html#python-methods",
    "href": "python-in-r.html#python-methods",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.5 Python Methods",
    "text": "16.5 Python Methods\nYou might have heard people (i.e. me) say that Python is more “object-oriented” whereas R is more “functional.” What I mean is that in R you mostly apply functions to objects, but in Python you often call special functions that belong to certain object types. Here’s an example of converting a string to upper case:\n\n\nR: We use the string \"foo\" as an argument to the str_to_upper() function from the stringr library, which returns \"FOO\".\n\nstringr::str_to_upper(\"foo\")\n\n#> [1] \"FOO\"\n\n\n\n\nPython: we use the .upper() method that belongs to the string \"foo\", which returns \"FOO\". All strings in Python have this method.\n\n\"foo\".upper()\n\n## 'FOO'\n\n\nMethods are special functions that belong to objects of a certain class. You “call” methods using the name of the object followed by the . symbol, like this:\n\nobject.method()\n\nYou can also see the different methods available for a particular object by calling the dir function on the object:\n\ns = \"foo\"\ndir(s)\n\n## ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\nWow, strings have a lot of methods!\nThe concept of using methods is a major part of the “object-oriented” way of programming, since it’s the object that is the center of attention. The object in Python is more than just a stored value - it’s a source of other methods (depending on the object’s class).\nNow that you’ve seen a little about how Python methods work, we’ll get to use some working with strings!"
  },
  {
    "objectID": "python-in-r.html#strings",
    "href": "python-in-r.html#strings",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.6 Strings",
    "text": "16.6 Strings\nString manipulation is one area where more substantial differences emerge between Python and R. Because R’s built in functions for dealing with strings are rather unintuitive, we’ve relied on the stringr package:\n\nlibrary(stringr)\n\nIn Python, many of the basic string manipulations are actually done with basic arithmatic operators, just like with numbers. Here are a few comparisons:\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\nString concatenation:\n\n\nIn R, we use the function paste() to combine strings:\n\npaste(\"foo\", \"bar\", sep = \"\")\n\n#> [1] \"foobar\"\n\n\n\n\nIn Python, you can combine strings by “adding” them together. The default is to merge them with no space in between:\n\n\"foo\" + \"bar\"\n\n## 'foobar'\n\n\n\n\nString repetition:\n\n\nCreating a repeated string is even more complicated in R. You first have to create a vector of repeated strings, and then “collapse” them using the paste() function:\n\npaste(rep(\"foo\", 3), collapse = '')\n\n#> [1] \"foofoofoo\"\n\n\n\n\nIn Python, you can just “multiply” the string, like this:\n\n\"foo\" * 3\n\n## 'foofoofoo'\n\n\n\n\nSub-string detection:\n\n\nIn R, we use the str_detect() function:\n\nstr_detect('Apple', 'ppl')\n\n#> [1] TRUE\n\n\n\n\nIn Python, you can detect sub-strings using the in operator:\n\n'ppl' in 'Apple'\n\n## True\n\n\n\n16.6.1 Functions and methods\nBecause Python has both functions and object methods, it can sometimes be tricky to remember which to use for a specific purpose. For example, if you want to know how many characters are in a string, you use a function, just like in R:\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\nString length:\n\n\n\nstr_length('foo')\n\n#> [1] 3\n\n\n\n\n\nlen('foo')\n\n## 3\n\n\nHowever, lots of basic string manipulations are done with string methods:\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\nCase converstion:\n\n\n\ns <- \"A longer string\"\nstr_to_upper(s)\n\n#> [1] \"A LONGER STRING\"\n\nstr_to_lower(s)\n\n#> [1] \"a longer string\"\n\nstr_to_title(s)\n\n#> [1] \"A Longer String\"\n\n\n\n\n\ns = \"A longer string\"\ns.upper()\n\n## 'A LONGER STRING'\n\ns.lower()\n\n## 'a longer string'\n\ns.title()\n\n## 'A Longer String'\n\n\n\n\nRemove excess white space:\n\n\n\ns <- \"     A string with space     \"\nstr_trim(s)\n\n#> [1] \"A string with space\"\n\n\n\n\n\ns = \"     A string with space     \"\ns.strip()\n\n## 'A string with space'\n\n\n\n\nDetect if string contains only numbers:\n\n\nR doesn’t have a function for this, but you can convert it to a number and check if the result is not NA:\n\ns <- \"42\"\n!is.na(as.numeric(s))\n\n#> [1] TRUE\n\n\n\n\nPython has some handy string methods!\n\ns = \"42\"\ns.isnumeric()\n\n## True\n\n\n\n16.6.2 Slicing\nTo extract a sub-string, in R we have to use the str_sub() function. But in Python, you can simply use the [] symbols. In either case, you have to provide indices of where to start and stop the “slice”.\nFor example, here’s how to extract the sub-string \"App\" from \"Apple\" in each language:\n\n\nR:\n\ns <- \"Apple\"\nstr_sub(s, 1, 3)\n\n#> [1] \"App\"\n\n\n\n\nPython:\n\ns = \"Apple\"\ns[0:3]\n\n## 'App'\n\n\nNote that we had to use a different starting index here to get the same sub-string in each language. That’s because indexing starts at 0 in Python.\nIf this seems strange, just imagine “fence posts”. In Python, the elements in a sequence are like items sitting between fence posts. So the index of each character in the string \"Apple\" look like this:\n\nindex: 0     1     2     3     4     5\n       |     |     |     |     |     |\n       | \"A\" | \"p\" | \"p\" | \"l\" | \"e\" |\n       |     |     |     |     |     |\n\nWhen you make a slice in Python, you slice at the fence post number to get the elements between the posts. So in this case, if we want to get the sub-string \"App\" from \"Apple\", we need to slice from the post 0 to 3.\nNegative indices are also handled differently.\n\n\nR: Negative indices start from the end of the string inclusively:\n\nstr_sub(s, -1)\n\n#> [1] \"e\"\n\nstr_sub(s, -3)\n\n#> [1] \"ple\"\n\n\n\n\nPython: Negative indices start from the end of the string, but only return the character at that index:\n\ns[-1]\n\n## 'e'\n\ns[-3]\n\n## 'p'\nTo get an inclusive string, you have to provide a starting and ending index:\n\ns[-3:-1]\n\n## 'pl'\n\ns[-3:5]\n\n## 'ple'\n\n\nYou can get the index of a character or sub-string in Python using the .index() method:\n\n\nR: Returns the starting and ending indices of the sub-string\n\nstr_locate(s, \"pp\")\n\n#>      start end\n#> [1,]     2   3\n\n\n\n\nPython: Returns only the starting index of the sub-string\n\ns.index(\"pp\")\n\n## 1"
  },
  {
    "objectID": "python-in-r.html#splitting-strings",
    "href": "python-in-r.html#splitting-strings",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.7 Splitting strings",
    "text": "16.7 Splitting strings\nLike in R, splitting a string returns a list of strings. Python lists are similar to R lists, but they only have single brackets. Here’s an example:\n\n\nR:\n\ns <- \"Apple\"\nstr_split(s, \"pp\")\n\n#> [[1]]\n#> [1] \"A\"  \"le\"\n\n\n\n\nPython:\n\ns = \"Apple\"\ns.split(\"pp\")\n\n## ['A', 'le']\n\n\nIn both languages, the returned list contains the remaining characters after splitting the string (in this case, \"A\" and \"le\"). One main difference though is that R returns a list of vectors, so to access the returned vector containing \"A\" and \"le\" you have to access the first element in the list, like this:\n\nstr_split(s, \"pp\")[[1]]\n\n#> [1] \"A\"  \"le\"\n\n\nThis is because in R the str_split() function is vectorized, meaning that the function can also be performed on a vector of strings, like this:\n\ns <- c(\"Apple\", \"Snapple\")\nstr_split(s, \"pp\")\n\n#> [[1]]\n#> [1] \"A\"  \"le\"\n#> \n#> [[2]]\n#> [1] \"Sna\" \"le\"\n\n\nIn this example, it’s easier to see that R is returning a list of vectors. In contrast, Python cannot perform a split on multiple strings:\n\ns = [\"Apple\", \"Snapple\"]\ns.split(\"pp\")\n\n## AttributeError: 'list' object has no attribute 'split'\nTo handle this, you will need to import the numpy package, which has an “array” structure similar to R vectors (we’ll cover this in more detail on week 13). Here’s an example:\n\nimport numpy as np\n\ns = np.array([\"Apple\", \"Snapple\"])\nnp.char.split(s, \"pp\")\n\n## array([list(['A', 'le']), list(['Sna', 'le'])], dtype=object)"
  },
  {
    "objectID": "python-in-r.html#running-a-python-script-in-r",
    "href": "python-in-r.html#running-a-python-script-in-r",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.8 Running a Python script in R",
    "text": "16.8 Running a Python script in R\nWhile R scripts end in .R, Python scripts end in .py. You can open up and save a blank Python script in RStudio by clicking\n\nFile -> New File -> Python Script\n\nSave it as foo.py in your project folder. Now that it’s saved, let’s add some code to run. As a quick example, I’m going to add code defining the function isOdd() and then create a few values testing it:\n\ndef isOdd(n):\n    if (n % 2 == 1):\n        return(True)\n    return(False)\n\nn1 = isOdd(4)\nn2 = isOdd(3)\n\nNow that you have this code stored in your foo.py file, you can source the file from inside R, like this:\n\nreticulate::source_python('foo.py')\n\nMagically, the function isOdd() and the objects we created (n1 and n2) are now accessible from R!\n\nisOdd(7)\n\n## [1] TRUE\n\nn1\n\n## [1] FALSE\n\nn2\n\n## [1] TRUE"
  },
  {
    "objectID": "python-in-r.html#summary-of-rpython-differences",
    "href": "python-in-r.html#summary-of-rpython-differences",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.9 Summary of R/Python differences",
    "text": "16.9 Summary of R/Python differences\n\nIndexing starts at 0 in Python and 1 in R.\nStrings in Python can be manipulated with arithmetic operators.\nPython is more “object-oriented” whereas R is more “functional”."
  },
  {
    "objectID": "python-in-r.html#tips",
    "href": "python-in-r.html#tips",
    "title": "16  Introduction to Python (in R)",
    "section": "\n16.10 Tips",
    "text": "16.10 Tips\n\n16.10.1 Making your own Python class\nYou can get really creative with object-oriented programming in Python by creating your own custom classes, allowing you to embed values and methods that belong only to objects of that class. For example, here’s how to create a class called Animal, which is defined by two values: species and sound. Note the white space indentations - without them Python will error:\n\nclass Animal:\n    def __init__(self, species, sound):\n        self.species = species\n        self.sound = sound\n\nThe first function in any custom class is the __init__ function. This is where to define any arguments that must be input when defining an object of the custom class. The use of self here defines which methods and values will be stored in the object onces it’s created.\nHere’s a example of how we could use the Animal class:\n\nriley = Animal(\"Dog\", \"Woof\")\n\nHere I’ve defined an object named riley (my dog’s name), and it has two stored values: \"Dog\" (the species) and \"Woof\" (the sound). I can access these stored values by calling the species and sound values from the riley object:\n\nriley.species\n\n## 'Dog'\n\nriley.sound\n\n## 'Woof'\nI can also ask Python what type of object riley is, and it will tell me it’s of the Animal class:\n\ntype(riley)\n\n<class '__main__.Animal'>\nIn addition to just storing values, you can create custom methods that will only be accessible to objects of the custom class. Here I’m adding the method introduce() to the class Animal:\n\nclass Animal:\n    def __init__(self, species, sound):\n        self.species = species\n        self.sound = sound\n\n    def introduce(self):\n        print(\"I'm a \" + self.species + \" and I say \" + self.sound)\n\nNow let’s re-define my riley object and try out our new method!\n\nriley = Animal(\"Dog\", \"Woof\")\nriley.introduce()\n\n## I'm a Dog and I say Woof"
  }
]